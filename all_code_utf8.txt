=== C:\telegramm_bots_new\check-list-admin-bot-new\cmd\bot\main.go ===
package main

import (
	"context"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"telegram-bot/config"
	"telegram-bot/internal/handlers"
	"telegram-bot/internal/routes"

	"telegram-bot/internal/services/answers"
	"telegram-bot/internal/services/auth"
	"telegram-bot/internal/services/block_checklist"
	"telegram-bot/internal/services/menu"
	"telegram-bot/internal/services/my_checklists"
	"telegram-bot/internal/services/published_checklists"
	"telegram-bot/internal/services/question"
	"telegram-bot/internal/services/question_edit"
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/services/simple_checklist"
	"telegram-bot/internal/state_manager/manager"
	"telegram-bot/internal/storage/infrastructure"
	"telegram-bot/internal/storage/repositories"
	"telegram-bot/internal/storage/service"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

func main() {
	// 1. Graceful shutdown
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		sig := <-sigChan
		log.Printf("🛑 Получен сигнал %v, завершаю работу...", sig)
		cancel()
		time.Sleep(2 * time.Second)
		log.Println("👋 Бот остановлен")
		os.Exit(0)
	}()

	// 2. Загрузка конфигурации
	cfg, err := config.LoadFromEnv()
	if err != nil {
		log.Fatal("Failed to load config:", err)
	}

	// 3. Инициализация бота
	bot, err := tgbotapi.NewBotAPI(cfg.Telegram.Token)
	if err != nil {
		log.Fatal("Failed to create bot:", err)
	}

	bot.Debug = false
	log.Printf("🤖 %s ЗАПУЩЕН", bot.Self.UserName)
	log.Println("==========================================")

	// 4. Инициализация StateManager
	stateMgr := manager.NewMemoryStateManager()

	// 5. Инициализация базы данных
	dbClient, err := infrastructure.NewDatabaseClient(cfg.Database.URL, cfg.Database.Key)
	if err != nil {
		log.Fatal("Failed to create database client:", err)
	}

	// 6. Инициализация репозиториев
	supabaseAdapter := repositories.NewSupabaseAdapter(dbClient.Client())
	userSvc := service.NewUserService(supabaseAdapter)

	// Новые репозитории для работы с чек-листами
	checklistRepo := repositories.NewChecklistRepository(dbClient.Client())
	questionBlockRepo := repositories.NewQuestionBlockRepository(dbClient.Client())
	questionRepo := repositories.NewQuestionRepository(dbClient.Client())
	answerOptionRepo := repositories.NewAnswerOptionRepository(dbClient.Client())
	templateRepo := repositories.NewChecklistTemplateRepository(dbClient.Client())

	// Инициализация сервиса чек-листов
	checklistSvc := service.NewChecklistService(
		checklistRepo,
		questionBlockRepo,
		questionRepo,
		answerOptionRepo,
		templateRepo,
		supabaseAdapter,
	)

	// Инициализация сервисов работы с бизнес логикой
	screenSvc := screen.NewScreenService(bot)
	authSvc := auth.NewAuthService(stateMgr, userSvc, screenSvc)

	// Создаем MyChecklistsService
	myChecklistsSvc := my_checklists.NewMyChecklistsService(stateMgr, screenSvc, checklistSvc)

	// Создаем PublishedChecklistsService
	publishedChecklistsSvc := published_checklists.NewPublishedChecklistsService(stateMgr, screenSvc, checklistSvc)

	// Создаем MenuService
	menuSvc := menu.NewMenuService(stateMgr, screenSvc, checklistSvc, publishedChecklistsSvc)

	// Инициализация сервисов для вопросов и ответов
	questionSvc := question.NewQuestionService(stateMgr, screenSvc)
	answersSvc := answers.NewAnswersService(stateMgr, screenSvc, questionSvc)
	questionEditSvc := question_edit.NewQuestionEditService(stateMgr, screenSvc, questionSvc, answersSvc)

	// Инициализация сервисов для чек-листов
	simpleChecklistSvc := simple_checklist.NewSimpleChecklistService(stateMgr, screenSvc, questionEditSvc, checklistSvc)
	blockChecklistSvc := block_checklist.NewBlockChecklistService(stateMgr, screenSvc, checklistSvc)

	// Инициализация роутов
	authRoute := routes.NewAuthRoutes(authSvc, screenSvc)
	menuRoute := routes.NewMenuRoutes(menuSvc, screenSvc)
	simpleChecklistRoute := routes.NewSimpleChecklistRoutes(simpleChecklistSvc, screenSvc)
	blockChecklistRoute := routes.NewBlockChecklistRoutes(blockChecklistSvc, screenSvc)
	questionRoute := routes.NewQuestionRoutes(questionSvc, screenSvc)
	answersRoute := routes.NewAnswersRoutes(answersSvc, screenSvc)
	questionEditRoute := routes.NewQuestionEditRoutes(questionEditSvc, screenSvc)
	myChecklistsRoute := routes.NewMyChecklistsRoutes(myChecklistsSvc, screenSvc)
	publishedRoute := routes.NewPublishedChecklistsRoutes(publishedChecklistsSvc, screenSvc)

	// Инициализация роутера
	router := routes.NewRouter(
		stateMgr,
		userSvc,
		authRoute,
		menuRoute,
		simpleChecklistRoute,
		blockChecklistRoute,
		questionRoute,
		answersRoute,
		questionEditRoute,
		myChecklistsRoute,
		publishedRoute,
	)

	// Инициализация обработчика обновлений
	updateHandler := handlers.NewUpdateHandler(router, stateMgr)

	// Настройка получения обновлений
	u := tgbotapi.NewUpdate(0)
	u.Timeout = 60
	updates := bot.GetUpdatesChan(u)

	log.Println("🚀 Бот запущен и ожидает сообщений...")
	log.Println("==========================================")

	// Главный цикл с graceful shutdown
	for {
		select {
		case update := <-updates:
			go updateHandler.HandleUpdate(update)

		case <-ctx.Done():
			log.Println("🛑 Останавливаю получение новых сообщений...")
			return
		}
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\config\config.go ===
package config

type Config struct {
	Telegram struct {
		Token string `validate:"required"`
	}
	Database struct {
		URL string `validate:"required"`
		Key string `validate:"required"`
	}
	Server struct {
		Port string `default:":8080"`
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\config\defaults.go ===
package config

func setDefaults(cfg *Config) {
	if cfg.Server.Port == "" {
		cfg.Server.Port = "8080"
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\config\env.go ===
package config

import (
	"os"

	"github.com/joho/godotenv"
)

func LoadFromEnv() (*Config, error) {
	godotenv.Load()

	cfg := &Config{}
	cfg.Telegram.Token = os.Getenv("TELEGRAM_BOT_TOKEN")
	cfg.Database.URL = os.Getenv("SUPABASE_URL")
	cfg.Database.Key = os.Getenv("SUPABASE_KEY")
	cfg.Server.Port = os.Getenv("PORT")

	setDefaults(cfg)
	return cfg, validate(cfg)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\config\validation.go ===
package config

import "errors"

func validate(cfg *Config) error {
	if cfg.Telegram.Token == "" {
		return errors.New("TELEGRAM_BOT_TOKEN is required")
	}
	if cfg.Database.URL == "" {
		return errors.New("SUPABASE_URL is required")
	}
	if cfg.Database.Key == "" {
		return errors.New("SUPABASE_KEY is required")
	}
	return nil
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\buttons\constants.go ===
package buttons

// Невидимый символ Zero Width Space (U+200B)
const zeroWidthSpace = ""

// Константы для всех кнопок
const (
	// Админ меню
	BtnAuth                  = "🔐 Авторизоваться" + zeroWidthSpace
	BtnCreateSimpleChecklist = "📋 Создать чек-лист" + zeroWidthSpace
	BtnCreateBlockChecklist  = "🧱 Создать чек-лист с блоками" + zeroWidthSpace
	BtnMyChecklists          = "📝 Мои чек-листы" + zeroWidthSpace
	BtnPublished             = "🚀 Опубликованные" + zeroWidthSpace
	BtnCanceled              = "🚫 Отмененные публикации" + zeroWidthSpace
	BtnStatistics            = "📊 Статистика" + zeroWidthSpace
	BtnLogout                = "🚪 Выход" + zeroWidthSpace

	// Типы вопросов
	BtnCompliance     = "✅ Соответствие" + zeroWidthSpace
	BtnSingleChoice   = "🔘 Одиночный выбор" + zeroWidthSpace
	BtnMultipleChoice = "☑️ Множественный выбор" + zeroWidthSpace
	BtnTextAnswer     = "📝 Текстовый ответ" + zeroWidthSpace

	// Навигация
	BtnBack            = "◀️ Назад" + zeroWidthSpace
	BtnBackToMainMenu  = "◀️ Назад в главное меню" + zeroWidthSpace
	BtnBackToBlockList = "◀️ К списку блоков" + zeroWidthSpace

	// Редактирование вопросов
	BtnEditQuestionText = "✏️ Изменить текст вопроса" + zeroWidthSpace
	BtnEditQuestionType = "✏️ Изменить тип вопроса" + zeroWidthSpace
	BtnDeleteQuestion   = "🗑️ Удалить вопрос" + zeroWidthSpace
	BtnEdit             = "✏️ Редактировать" + zeroWidthSpace

	// Подтверждение
	BtnYes = "🟢 Да" + zeroWidthSpace
	BtnNo  = "🔴 Нет" + zeroWidthSpace

	// Редактор чек-листа
	BtnAddQuestion             = "➕ Добавить вопрос" + zeroWidthSpace
	BtnAddBlock                = "➕ Добавить блок" + zeroWidthSpace
	BtnEditTitleBlockChecklist = "✏️ Редактировать название блока" + zeroWidthSpace
	BtnPreview                 = "👁️ Посмотреть превью" + zeroWidthSpace
	BtnEditTitleChecklist      = "✏️ Редактировать название" + zeroWidthSpace
	BtnEditQuestionChecklist   = "✏️ Редактировать вопросы" + zeroWidthSpace
	BtnPreviewBlock            = "👁️ Превью блока" + zeroWidthSpace
	BtnPublishChecklist        = "🚀 Опубликовать" + zeroWidthSpace

	// BtnEditTitleBlockChecklist = "✏️ Название блока"

	BtnSaveDraft   = "💾 Сохранить черновик" + zeroWidthSpace
	BtnSavePublish = "💾🚀 Сохранить и опубликовать" + zeroWidthSpace

	BtnUnPublish = "🚫 Снять с публикации"
	BtnPublish   = "🚀 Вернуть в публикацию"

	BtnDeleteCheckList = "🗑️ Удалить"
	BtnEditCheckList   = "✏️ Редактировать чек-лист" + zeroWidthSpace
)

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\formatters\block_formatter.go ===
package formatters

import (
	"fmt"
	"strings"
	"telegram-bot/internal/state_manager/types"
)

func FormatBlockPreview(block types.Block) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("🧱 ПРЕВЬЮ БЛОКА: %s\n", block.Name))
	sb.WriteString("═════════════════════\n\n")

	sb.WriteString(fmt.Sprintf("📊 Количество вопросов: %d\n\n", len(block.Questions)))

	sb.WriteString("═════════════════════\n")
	sb.WriteString("📝 ВОПРОСЫ:\n")
	sb.WriteString("═════════════════════\n\n")

	for i, question := range block.Questions {
		sb.WriteString(fmt.Sprintf("%d. %s\n", i+1, question.Text))
		sb.WriteString(fmt.Sprintf("   📌 Тип: %s\n", FormatQuestionType(question.Category)))

		if len(question.AnswerOptions) > 0 {
			sb.WriteString("   📊 Варианты ответов:\n")
			for j, option := range question.AnswerOptions {
				sb.WriteString("     ")
				if option.IsCorrect {
					sb.WriteString("✅ ")
				} else {
					sb.WriteString("   ")
				}
				sb.WriteString(fmt.Sprintf("%d. %s\n", j+1, option.Text))
			}
		}
		sb.WriteString("\n")
	}

	sb.WriteString("═════════════════════\n")
	sb.WriteString("Вы остаетесь в редакторе блока\n")

	return sb.String()
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\formatters\checklist_formatter.go ===
package formatters

import (
	"fmt"
	"strings"
	"telegram-bot/internal/storage/models"
)

func FormatChecklist(checklist *models.Checklist, hasBlocks bool, blocks []models.QuestionBlock, templates []models.ChecklistTemplate, questions []models.Question, answerOptions []models.AnswerOption) string {
	var sb strings.Builder

	// Заголовок в зависимости от статуса
	switch checklist.Status {
	case models.StatusPublished:
		sb.WriteString("🚀 ПРЕВЬЮ ЧЕК-ЛИСТА (ОПУБЛИКОВАН)\n")
	case models.StatusUnpublished:
		sb.WriteString("🚫 ПРЕВЬЮ ЧЕК-ЛИСТА (ОТМЕНЕН)\n")
	default: // StatusDraft
		sb.WriteString("📋 ПРЕВЬЮ ЧЕК-ЛИСТА\n")
	}

	sb.WriteString("═════════════════════\n\n")

	sb.WriteString(fmt.Sprintf("🏷️ Название: %s\n", checklist.Name))
	sb.WriteString(fmt.Sprintf("📊 ID: %d\n", checklist.ID))

	answersByQuestion := make(map[int64][]models.AnswerOption)
	for _, ao := range answerOptions {
		answersByQuestion[ao.QuestionID] = append(answersByQuestion[ao.QuestionID], ao)
	}

	if hasBlocks && len(blocks) > 0 {
		sb.WriteString("🎯 Тип: С блоками\n")
		sb.WriteString(fmt.Sprintf("🧱 Блоков: %d\n", len(blocks)))

		questionsByBlock := make(map[int64][]models.Question)
		questionMap := make(map[int64]models.Question)

		for _, q := range questions {
			questionMap[q.ID] = q
		}

		for _, t := range templates {
			if t.BlockID != nil {
				if question, exists := questionMap[t.QuestionID]; exists && question.ID != 0 {
					questionsByBlock[*t.BlockID] = append(questionsByBlock[*t.BlockID], question)
				}
			}
		}

		sb.WriteString("\n═════════════════════\n")

		for b, block := range blocks {
			sb.WriteString(fmt.Sprintf("🧱 БЛОК %d: %s\n", b+1, block.Name))
			sb.WriteString("═════════════════════\n\n")

			if blockQuestions, ok := questionsByBlock[block.ID]; ok && len(blockQuestions) > 0 {
				for i, question := range blockQuestions {
					formatQuestion(&sb, question, answersByQuestion[question.ID], i, "  ")
				}
			} else {
				sb.WriteString("  📭 В блоке нет вопросов\n\n")
			}
		}

	} else {
		sb.WriteString("🎯 Тип: Простой\n")
		sb.WriteString(fmt.Sprintf("❓ Вопросов: %d\n", len(questions)))

		sb.WriteString("\n═════════════════════\n")
		sb.WriteString("📝 ВОПРОСЫ:\n")
		sb.WriteString("═════════════════════\n\n")

		for i, question := range questions {
			formatQuestion(&sb, question, answersByQuestion[question.ID], i, "")
		}
	}

	sb.WriteString("\n═════════════════════\n")
	createdAtStr := "(дата недоступна)"
	if !checklist.CreatedAt.IsZero() && checklist.CreatedAt.Year() > 1 {
		createdAtStr = checklist.CreatedAt.Format("02.01.2006 15:04")
	}
	sb.WriteString(fmt.Sprintf("📅 Создан: %s\n", createdAtStr))
	sb.WriteString(fmt.Sprintf("📊 Статус: %s\n", checklist.Status))

	sb.WriteString("\n═════════════════════\n")
	sb.WriteString("Выберите действие:")

	return sb.String()
}
func formatQuestion(sb *strings.Builder, question models.Question, options []models.AnswerOption, index int, prefix string) {
	sb.WriteString(fmt.Sprintf("%s%d. %s\n", prefix, index+1, question.Text))
	sb.WriteString(fmt.Sprintf("%s   📌 Тип: %s\n", prefix, FormatQuestionTypeModels(question.Category)))

	if len(options) > 0 {
		sb.WriteString(fmt.Sprintf("%s   📊 Варианты ответов:\n", prefix))
		for j, option := range options {
			sb.WriteString(prefix + "     ")
			if option.IsCorrect {
				sb.WriteString("✅ ")
			} else {
				sb.WriteString("   ")
			}
			sb.WriteString(fmt.Sprintf("%d. %s\n", j+1, option.Text))
		}
	}
	sb.WriteString("\n")
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\formatters\question_type_formatter.go ===
package formatters

import (
	"telegram-bot/internal/state_manager/types"
	"telegram-bot/internal/storage/models"
)

func FormatQuestionType(category types.QuestionCategory) string {
	switch category {
	case types.CategoryCompliance:
		return "✅ Соответствие"
	case types.CategorySingleChoice:
		return "🔘 Одиночный выбор"
	case types.CategoryMultipleChoice:
		return "☑️ Множественный выбор"
	case types.CategoryTextAnswer:
		return "📝 Текстовый ответ"
	default:
		return string(category)
	}
}

func FormatQuestionTypeModels(category models.QuestionCategory) string {
	switch category {
	case models.CategoryCompliance:
		return "✅ Соответствие"
	case models.CategorySingleChoice:
		return "🔘 Одиночный выбор"
	case models.CategoryMultipleChoice:
		return "☑️ Множественный выбор"
	case models.CategoryTextAnswer:
		return "📝 Текстовый ответ"
	default:
		return string(category)
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\formatters\state_checklist_formatter.go ===
package formatters

import (
	"fmt"
	"strings"
	"telegram-bot/internal/state_manager/types"
)

func FormatSimpleChecklistPreview(checklist *types.SimpleCheckList) string {
	var sb strings.Builder

	sb.WriteString("📋 ПРЕВЬЮ ЧЕК-ЛИСТА\n")
	sb.WriteString("═════════════════════\n\n")

	sb.WriteString("🏷️ Название: ")
	sb.WriteString(checklist.Name)
	sb.WriteString("\n")

	sb.WriteString("📊 Статус: ")
	sb.WriteString(string(checklist.Status))
	sb.WriteString("\n")

	sb.WriteString("❓ Количество вопросов: ")
	sb.WriteString(fmt.Sprintf("%d", len(checklist.Questions)))
	sb.WriteString("\n\n")

	sb.WriteString("═════════════════════\n")
	sb.WriteString("📝 ВОПРОСЫ:\n")
	sb.WriteString("═════════════════════\n\n")

	for i, question := range checklist.Questions {
		formatStateQuestion(&sb, question, i, "")
	}

	sb.WriteString("═════════════════════\n")
	sb.WriteString("Выберите действие:\n")

	return sb.String()
}

func FormatBlockedChecklistPreview(checklist *types.BlockedCheckList) string {
	var sb strings.Builder

	sb.WriteString("📋 ПРЕВЬЮ ЧЕК-ЛИСТА С БЛОКАМИ\n")
	sb.WriteString("═════════════════════\n\n")

	sb.WriteString("🏷️ Название: ")
	sb.WriteString(checklist.Name)
	sb.WriteString("\n")

	sb.WriteString("📊 Статус: ")
	sb.WriteString(string(checklist.Status))
	sb.WriteString("\n")

	sb.WriteString("🧱 Количество блоков: ")
	sb.WriteString(fmt.Sprintf("%d", len(checklist.Blocks)))
	sb.WriteString("\n\n")

	totalQuestions := 0
	for _, block := range checklist.Blocks {
		totalQuestions += len(block.Questions)
	}
	sb.WriteString("❓ Общее количество вопросов: ")
	sb.WriteString(fmt.Sprintf("%d", totalQuestions))
	sb.WriteString("\n\n")

	for b, block := range checklist.Blocks {
		sb.WriteString("═════════════════════\n")
		sb.WriteString("🧱 БЛОК ")
		sb.WriteString(fmt.Sprintf("%d", b+1))
		sb.WriteString(": ")
		sb.WriteString(block.Name)
		sb.WriteString("\n")
		sb.WriteString("═════════════════════\n\n")

		for i, question := range block.Questions {
			formatStateQuestion(&sb, question, i, "  ")
		}
	}

	sb.WriteString("═════════════════════\n")
	sb.WriteString("Выберите действие:\n")

	return sb.String()
}

func formatStateQuestion(sb *strings.Builder, question types.Question, index int, prefix string) {
	sb.WriteString(fmt.Sprintf("%s%d. %s\n", prefix, index+1, question.Text))
	sb.WriteString(fmt.Sprintf("%s   📌 Тип: %s\n", prefix, FormatQuestionType(question.Category)))

	if len(question.AnswerOptions) > 0 {
		sb.WriteString(fmt.Sprintf("%s   📊 Варианты ответов:\n", prefix))
		for j, option := range question.AnswerOptions {
			sb.WriteString(prefix + "     ")
			if option.IsCorrect {
				sb.WriteString("✅ ")
			} else {
				sb.WriteString("   ")
			}
			sb.WriteString(fmt.Sprintf("%d. %s\n", j+1, option.Text))
		}
	}
	sb.WriteString("\n")
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\handlers\update_handler.go ===
package handlers

import (
	"fmt"
	"log"

	"telegram-bot/internal/state_manager/debug"
	"telegram-bot/internal/state_manager/manager"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// UpdateHandler обрабатывает входящие обновления Telegram
type UpdateHandler struct {
	stateMgr manager.StateManager
	router   interface {
		Route(userID int64, update tgbotapi.Update, text string)
	}
}

// NewUpdateHandler создает новый обработчик обновлений
func NewUpdateHandler(router interface {
	Route(userID int64, update tgbotapi.Update, text string)
}, stateMgr manager.StateManager) *UpdateHandler {
	return &UpdateHandler{
		stateMgr: stateMgr,
		router:   router,
	}
}

// HandleUpdate обрабатывает одно обновление Telegram
func (h *UpdateHandler) HandleUpdate(update tgbotapi.Update) {
	// Пропускаем не текстовые сообщения
	if update.Message == nil {
		return
	}
	userID := update.Message.From.ID
	text := update.Message.Text
	// Передаем в роутер
	h.router.Route(userID, update, text)

	// Получаем и логируем состояние ПОСЛЕ обработки
	log.Println("\n📊 ТЕКУЩЕЕ СОСТОЯНИЕ:")
	if state, exists := h.stateMgr.GetState(userID); exists {
		fmt.Print(state)
		debug.PrintState(state)
	}

}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\routes\answers_routes.go ===
package routes

import (
	"log"

	"telegram-bot/internal/buttons"
	"telegram-bot/internal/services/answers"
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/state"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

type AnswersRoutes struct {
	answersSvc *answers.AnswersService
	screenSvc  *screen.ScreenService
}

func NewAnswersRoutes(answersSvc *answers.AnswersService, screenSvc *screen.ScreenService) *AnswersRoutes {
	return &AnswersRoutes{
		answersSvc: answersSvc,
		screenSvc:  screenSvc,
	}
}

func (r *AnswersRoutes) Route(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	log.Printf("[AnswersRoutes] 👤 UserID: %d | 💬 Текст: %s | Экран: %s", userID, text, userState.GetCurrentScreen())

	switch text {
	case buttons.BtnBack:
		r.answersSvc.HandleBack(userID, update, userState)
	default:
		// Любой другой текст - это ввод вариантов или правильных ответов
		r.answersSvc.HandleUserInput(userID, update, userState, text)
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\routes\auth_routes.go ===
package routes

import (
	"log"

	"telegram-bot/internal/buttons"
	"telegram-bot/internal/services/auth"
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/state"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

type AuthRoutes struct {
	authSvc   *auth.AuthService
	screenSvc *screen.ScreenService
}

func NewAuthRoutes(authSvc *auth.AuthService, screenSvc *screen.ScreenService) *AuthRoutes {
	return &AuthRoutes{
		authSvc:   authSvc,
		screenSvc: screenSvc,
	}
}

func (r *AuthRoutes) Route(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	log.Printf("[AuthRoutes] 👤 UserID: %d | 💬 Текст: %s", userID, text)

	switch text {
	case buttons.BtnAuth:
		r.authSvc.HandleAuthorization(userID, update, userState)

	default:
		r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\routes\block_checklist_routes.go ===
package routes

import (
	"log"
	"strings"

	"telegram-bot/internal/buttons"
	"telegram-bot/internal/services/block_checklist"
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/utils"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// BlockChecklistRoutes содержит методы для маршрутизации чек-листов с блоками
type BlockChecklistRoutes struct {
	checklistSvc *block_checklist.BlockChecklistService
	screenSvc    *screen.ScreenService
}

func NewBlockChecklistRoutes(checklistSvc *block_checklist.BlockChecklistService, screenSvc *screen.ScreenService) *BlockChecklistRoutes {
	return &BlockChecklistRoutes{
		checklistSvc: checklistSvc,
		screenSvc:    screenSvc,
	}
}

// Route маршрутизирует сообщение в контексте чек-листов с блоками
func (r *BlockChecklistRoutes) Route(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	currentScreen := userState.GetCurrentScreen()

	log.Printf("[BlockChecklistRoutes] 👤 UserID: %d | 💬 Текст: %s | Экран: %s", userID, text, currentScreen)

	switch currentScreen {
	case "create-block-checklist-name":
		r.handleCreateNameScreen(userID, update, text, userState)
	case "block-checklist-editor":
		r.handleBlockListScreen(userID, update, text, userState)
	case "edit-block-name":
		r.handleEditBlockNameScreen(userID, update, text, userState)
	case "block-editor":
		r.handleBlockEditorScreen(userID, update, text, userState)
	case "edit-checklist-title":
		r.handleEditChecklistTitleScreen(userID, update, text, userState)
	case "checklist-preview":
		r.handleChecklistPreviewScreen(userID, update, text, userState)
	case "confirm-exit-block-checklist":
		r.handleConfirmExitScreen(userID, update, text, userState)
	case "block-view-questions":
		r.handleBlockViewQuestionsScreen(userID, update, text, userState)
	default:
		r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	}
}

// handleCreateNameScreen обрабатывает экран создания названия чек-листа
func (r *BlockChecklistRoutes) handleCreateNameScreen(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	switch text {
	case buttons.BtnBack:
		r.checklistSvc.HandleCancelCreateChecklist(userID, update, userState)
	default:
		r.checklistSvc.HandleCreateBlockChecklist(userID, update, userState, text)
	}
}

// handleBlockListScreen обрабатывает главный экран редактора блоков
func (r *BlockChecklistRoutes) handleBlockListScreen(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	switch text {
	case buttons.BtnAddBlock:
		r.checklistSvc.HandleAddBlock(userID, update, userState)
	case buttons.BtnPreview:
		r.checklistSvc.HandleBlockChecklistPreview(userID, update, userState)
	case buttons.BtnEditTitleChecklist:
		r.checklistSvc.HandleEditChecklistTitle(userID, update, userState)
	case buttons.BtnBackToMainMenu:
		r.checklistSvc.HandleConfirmExit(userID, update, userState)
	default:
		if isBlockButton(text) {
			r.checklistSvc.HandleBlockSelection(userID, update, userState, text)
		} else {
			r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
		}
	}
}

// handleEditBlockNameScreen обрабатывает экран ввода названия блока
func (r *BlockChecklistRoutes) handleEditBlockNameScreen(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	switch text {
	case buttons.BtnBack:
		r.checklistSvc.HandleCancelBlockEdit(userID, update, userState)
	default:
		// Вызываем единый метод для обработки ввода названия блока
		r.checklistSvc.HandleBlockNameInput(userID, update, userState, text)
	}
}

// handleBlockEditorScreen обрабатывает экран редактора конкретного блока
func (r *BlockChecklistRoutes) handleBlockEditorScreen(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	switch text {
	case buttons.BtnBackToBlockList:
		r.checklistSvc.HandleBackFromBlockEditor(userID, update, userState)
	case buttons.BtnAddQuestion:
		r.checklistSvc.HandleAddQuestionToBlock(userID, update, userState)
	case buttons.BtnEditTitleBlockChecklist:
		r.checklistSvc.HandleEditBlockName(userID, update, userState)
	case buttons.BtnEditQuestionChecklist:
		r.checklistSvc.HandleEditBlockQuestions(userID, update, userState)
	case buttons.BtnPreviewBlock:
		r.checklistSvc.HandleBlockPreview(userID, update, userState)
	default:
		r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	}
}

// handleEditChecklistTitleScreen обрабатывает экран редактирования названия чек-листа
func (r *BlockChecklistRoutes) handleEditChecklistTitleScreen(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	switch text {
	case buttons.BtnBack:
		r.checklistSvc.HandleBackFromTitleEdit(userID, update, userState)
	default:
		r.checklistSvc.HandleEditChecklistTitleInput(userID, update, userState, text)
	}
}

// handleChecklistPreviewScreen обрабатывает экран превью чек-листа
func (r *BlockChecklistRoutes) handleChecklistPreviewScreen(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	switch text {
	case buttons.BtnBack:
		r.checklistSvc.HandleBackFromPreview(userID, update, userState)
	case buttons.BtnSaveDraft:
		r.checklistSvc.HandleSaveDraft(userID, update, userState)
	case buttons.BtnSavePublish:
		r.checklistSvc.HandleSavePublish(userID, update, userState)
	default:
		r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	}
}

// handleConfirmExitScreen обрабатывает экран подтверждения выхода
func (r *BlockChecklistRoutes) handleConfirmExitScreen(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	switch text {
	case buttons.BtnYes:
		r.checklistSvc.HandleConfirmExitYes(userID, update, userState)
	case buttons.BtnNo:
		r.checklistSvc.HandleConfirmExitNo(userID, update, userState)
	default:
		r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	}
}

// handleBlockViewQuestionsScreen обрабатывает экран списка вопросов блока
func (r *BlockChecklistRoutes) handleBlockViewQuestionsScreen(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	// Проверяем, является ли текст кнопкой с карандашом и номером
	if utils.IsPencilNumberButton(text) {
		// Начинаем редактирование вопроса в блоке
		r.checklistSvc.HandleEditBlockQuestion(userID, update, userState, text)
		return
	}

	switch text {
	case buttons.BtnBack:
		r.checklistSvc.HandleBackFromBlockQuestions(userID, update, userState)
	default:
		r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	}
}

// isBlockButton проверяет, является ли текст кнопкой блока
func isBlockButton(text string) bool {
	return strings.HasPrefix(text, "🧱") || strings.HasPrefix(text, "📭") || strings.HasPrefix(text, "🏗️")
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\routes\main_router.go ===
package routes

import (
	"telegram-bot/internal/state_manager/manager"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"
	"telegram-bot/internal/storage/service"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Router маршрутизирует сообщения к обработчикам
type Router struct {
	stateMgr             manager.StateManager
	userSvc              *service.UserService
	authRoute            *AuthRoutes
	menuRoute            *MenuRoutes
	simpleChecklistRoute *SimpleChecklistRoutes
	blockChecklistRoute  *BlockChecklistRoutes
	questionRoute        *QuestionRoutes
	answersRoute         *AnswersRoutes
	questionEditRoute    *QuestionEditRoutes
	myChecklistsRoute    *MyChecklistsRoutes
	publishedRoute       *PublishedChecklistsRoutes
}

// NewRouter создает новый роутер
func NewRouter(
	stateMgr manager.StateManager,
	userSvc *service.UserService,
	authRoute *AuthRoutes,
	menuRoute *MenuRoutes,
	simpleChecklistRoute *SimpleChecklistRoutes,
	blockChecklistRoute *BlockChecklistRoutes,
	questionRoute *QuestionRoutes,
	answersRoute *AnswersRoutes,
	questionEditRoute *QuestionEditRoutes,
	myChecklistsRoute *MyChecklistsRoutes,
	publishedRoute *PublishedChecklistsRoutes,
) *Router {
	return &Router{
		stateMgr:             stateMgr,
		userSvc:              userSvc,
		authRoute:            authRoute,
		menuRoute:            menuRoute,
		simpleChecklistRoute: simpleChecklistRoute,
		blockChecklistRoute:  blockChecklistRoute,
		questionRoute:        questionRoute,
		answersRoute:         answersRoute,
		questionEditRoute:    questionEditRoute,
		myChecklistsRoute:    myChecklistsRoute, // Инициализируем новый роут
		publishedRoute:       publishedRoute,    // ИНИЦИАЛИЗИРУЙ
	}
}

// Route определяет текущий экран и вызывает соответствующий обработчик
func (r *Router) Route(userID int64, update tgbotapi.Update, text string) {

	// Получаем состояние пользователя
	userState, exists := r.stateMgr.GetState(userID)
	if !exists {
		// Создаем новое состояние
		userState = state.NewUserState(nil, "authorize-admin")
		r.stateMgr.SetState(userID, userState)
	}

	// Получаем текущий экран
	currentScreen := userState.GetCurrentScreen()
	if currentScreen == "" {
		currentScreen = "authorize-admin"
		userState.SetCurrentScreen(currentScreen)
	}

	// Маршрутизация по экранам
	switch currentScreen {
	case "authorize-admin":
		r.authRoute.Route(userID, update, text, userState)
	case "admin-menu":
		r.menuRoute.Route(userID, update, text, userState)
	case "create-simple-checklist-name":
		r.simpleChecklistRoute.Route(userID, update, text, userState)
	case "create-block-checklist-name":
		r.blockChecklistRoute.Route(userID, update, text, userState)

	// ========== ЭКРАНЫ ДЛЯ ОПУБЛИКОВАННЫХ/ОТМЕНЕННЫХ ==========
	case "published-checklists-list":
		r.publishedRoute.Route(userID, update, text, userState)
	case "published-checklist-detail":
		r.publishedRoute.Route(userID, update, text, userState)

	// ========== ЭКРАНЫ ДЛЯ МОИХ ЧЕК-ЛИСТОВ ==========
	case "my-checklists-list":
		r.myChecklistsRoute.Route(userID, update, text, userState)
	case "checklist-detail":
		r.myChecklistsRoute.Route(userID, update, text, userState)
	case "confirm-delete-checklist":
		r.myChecklistsRoute.Route(userID, update, text, userState)

	// ========== ЭКРАНЫ ДЛЯ ПРОСТЫХ ЧЕК-ЛИСТОВ ==========
	case "simple-checklist-editor":
		r.simpleChecklistRoute.Route(userID, update, text, userState)
	case "edit-checklist-title":
		// Определяем тип чек-листа для выбора правильного роутера
		if userState.HasCheckList() {
			switch userState.CurrentCheckList.(type) {
			case *types.BlockedCheckList:
				r.blockChecklistRoute.Route(userID, update, text, userState)
			default:
				r.simpleChecklistRoute.Route(userID, update, text, userState)
			}
		} else {
			r.simpleChecklistRoute.Route(userID, update, text, userState)
		}
	case "checklist-preview":
		// Определяем тип чек-листа для выбора правильного роутера
		if userState.HasCheckList() {
			switch userState.CurrentCheckList.(type) {
			case *types.BlockedCheckList:
				r.blockChecklistRoute.Route(userID, update, text, userState)
			default:
				r.simpleChecklistRoute.Route(userID, update, text, userState)
			}
		} else {
			r.simpleChecklistRoute.Route(userID, update, text, userState)
		}
	case "confirm-exit-to-main-menu":
		r.simpleChecklistRoute.Route(userID, update, text, userState)

	// ========== ЭКРАНЫ ДЛЯ ЧЕК-ЛИСТОВ С БЛОКАМИ ==========
	case "block-checklist-editor":
		r.blockChecklistRoute.Route(userID, update, text, userState)
	case "edit-block-name":
		r.blockChecklistRoute.Route(userID, update, text, userState)
	case "block-editor":
		r.blockChecklistRoute.Route(userID, update, text, userState)
	case "confirm-exit-block-checklist":
		r.blockChecklistRoute.Route(userID, update, text, userState)
	case "block-view-questions":
		r.blockChecklistRoute.Route(userID, update, text, userState)

	// ========== ЭКРАНЫ ВОПРОСОВ ==========
	case "select-question-type":
		r.questionRoute.Route(userID, update, text, userState)
	case "enter-question-text":
		r.questionRoute.Route(userID, update, text, userState)

	// ========== ЭКРАНЫ ОТВЕТОВ ==========
	case "enter-answer-options":
		r.answersRoute.Route(userID, update, text, userState)
	case "select-correct-answers":
		r.answersRoute.Route(userID, update, text, userState)

	// ========== ЭКРАНЫ РЕДАКТИРОВАНИЯ ВОПРОСОВ ==========
	case "view-question":
		r.questionEditRoute.Route(userID, update, text, userState)
	case "edit-question-text":
		r.questionEditRoute.Route(userID, update, text, userState)
	case "edit-question-type":
		r.questionEditRoute.Route(userID, update, text, userState)
	case "confirm-delete-question":
		r.questionEditRoute.Route(userID, update, text, userState)
	case "edit-question-detail":
		r.questionEditRoute.Route(userID, update, text, userState)

	default:
		r.stateMgr.NavigateTo(userID, "authorize-admin")
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\routes\menu_routes.go ===
package routes

import (
	"telegram-bot/internal/buttons"
	"telegram-bot/internal/services/menu"
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/state"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// MenuRoutes содержит методы для маршрутизации главного меню
type MenuRoutes struct {
	menuSvc   *menu.MenuService
	screenSvc *screen.ScreenService
}

// NewMenuRoutes создает новый роутер для главного меню
func NewMenuRoutes(menuSvc *menu.MenuService, screenSvc *screen.ScreenService) *MenuRoutes {
	return &MenuRoutes{
		menuSvc:   menuSvc,
		screenSvc: screenSvc,
	}
}

// Route маршрутизирует сообщение в главном меню
func (r *MenuRoutes) Route(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {

	switch text {
	case buttons.BtnCreateSimpleChecklist:
		r.menuSvc.HandleCreateSinpleChecklist(userID, update, userState)
	case buttons.BtnCreateBlockChecklist:
		r.menuSvc.HandleCreateBlocksChecklist(userID, update, userState)
	case buttons.BtnMyChecklists:
		r.menuSvc.HandleMyChecklists(userID, update, userState)
	case buttons.BtnPublished:
		r.menuSvc.HandlePublishedChecklists(userID, update, userState)
	case buttons.BtnCanceled:
		r.menuSvc.HandleCanceledChecklists(userID, update, userState)
	case buttons.BtnLogout:
		r.menuSvc.HandleLogout(userID, update, userState)
	default:
		r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\routes\my_checklists_routes.go ===
package routes

import (
	"log"

	"telegram-bot/internal/buttons"
	"telegram-bot/internal/services/my_checklists"
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/utils"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

type MyChecklistsRoutes struct {
	myChecklistsSvc *my_checklists.MyChecklistsService
	screenSvc       *screen.ScreenService
}

func NewMyChecklistsRoutes(myChecklistsSvc *my_checklists.MyChecklistsService, screenSvc *screen.ScreenService) *MyChecklistsRoutes {
	return &MyChecklistsRoutes{
		myChecklistsSvc: myChecklistsSvc,
		screenSvc:       screenSvc,
	}
}

func (r *MyChecklistsRoutes) Route(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	log.Printf("[MyChecklistsRoutes] 👤 UserID: %d | 💬 Текст: %s | Экран: %s", userID, text, userState.GetCurrentScreen())

	// Проверяем, является ли текст кнопкой с карандашом и номером (формат: "✏️ 1")
	if utils.IsPencilNumberButton(text) {
		r.myChecklistsSvc.HandleChecklistNumber(userID, update, userState, text)
		return
	}

	switch text {
	case buttons.BtnBack:
		r.handleBack(userID, update, userState)
	case buttons.BtnEditCheckList:
		r.myChecklistsSvc.HandleEditChecklist(userID, update, userState)
	case buttons.BtnDeleteCheckList:
		r.myChecklistsSvc.HandleDeleteChecklist(userID, update, userState)
	case buttons.BtnPublishChecklist:
		r.myChecklistsSvc.HandlePublishChecklist(userID, update, userState)
	case buttons.BtnYes:
		r.myChecklistsSvc.HandleConfirmDelete(userID, update, userState)
	case buttons.BtnNo:
		r.myChecklistsSvc.HandleCancelDelete(userID, update, userState)
	default:
		r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	}
}

func (r *MyChecklistsRoutes) handleBack(userID int64, update tgbotapi.Update, userState *state.UserState) {
	currentScreen := userState.GetCurrentScreen()

	switch currentScreen {
	case "my-checklists-list":
		r.myChecklistsSvc.HandleBackFromList(userID, update, userState)
	case "checklist-detail":
		// Возвращаемся к списку чек-листов
		r.myChecklistsSvc.HandleBackFromDetail(userID, update, userState)
	case "confirm-delete-checklist":
		// Возвращаемся к деталям чек-листа
		r.screenSvc.SendScreen(update.Message.Chat.ID, "checklist-detail", userState)
	default:
		r.screenSvc.SendScreen(update.Message.Chat.ID, "my-checklists-list", userState)
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\routes\published_checklists_routes.go ===
package routes

import (
	"log"

	"telegram-bot/internal/buttons"
	"telegram-bot/internal/services/published_checklists"
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/utils"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

type PublishedChecklistsRoutes struct {
	publishedSvc *published_checklists.PublishedChecklistsService
	screenSvc    *screen.ScreenService
}

func NewPublishedChecklistsRoutes(publishedSvc *published_checklists.PublishedChecklistsService, screenSvc *screen.ScreenService) *PublishedChecklistsRoutes {
	return &PublishedChecklistsRoutes{
		publishedSvc: publishedSvc,
		screenSvc:    screenSvc,
	}
}

func (r *PublishedChecklistsRoutes) Route(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	log.Printf("[PublishedChecklistsRoutes] 👤 UserID: %d | 💬 Текст: %s | Экран: %s", userID, text, userState.GetCurrentScreen())

	// Проверяем, является ли текст кнопкой с карандашом и номером
	if utils.IsPencilNumberButton(text) {
		r.publishedSvc.HandleChecklistNumber(userID, update, userState, text)
		return
	}

	switch text {
	case buttons.BtnBack:
		r.handleBack(userID, update, userState)
	case buttons.BtnUnPublish:
		r.publishedSvc.HandleUnpublish(userID, update, userState)
	case buttons.BtnPublish:
		r.publishedSvc.HandleRepublish(userID, update, userState)
	default:
		r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	}
}

func (r *PublishedChecklistsRoutes) handleBack(userID int64, update tgbotapi.Update, userState *state.UserState) {
	currentScreen := userState.GetCurrentScreen()

	switch currentScreen {
	case "published-checklists-list":
		r.publishedSvc.HandleBackFromList(userID, update, userState)
	case "published-checklist-detail":
		r.publishedSvc.HandleBackFromDetail(userID, update, userState)
	default:
		r.screenSvc.SendScreen(update.Message.Chat.ID, "published-checklists-list", userState)
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\routes\question_edit_routes.go ===
package routes

import (
	"log"

	"telegram-bot/internal/buttons"
	"telegram-bot/internal/services/question_edit"
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/utils"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

type QuestionEditRoutes struct {
	questionEditSvc *question_edit.QuestionEditService
	screenSvc       *screen.ScreenService
}

func NewQuestionEditRoutes(questionEditSvc *question_edit.QuestionEditService, screenSvc *screen.ScreenService) *QuestionEditRoutes {
	return &QuestionEditRoutes{
		questionEditSvc: questionEditSvc,
		screenSvc:       screenSvc,
	}
}

func (r *QuestionEditRoutes) Route(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	log.Printf("[QuestionEditRoutes] 👤 UserID: %d | 💬 Текст: %s | Экран: %s", userID, text, userState.GetCurrentScreen())

	// Проверяем, является ли текст кнопкой с карандашом и номером
	if utils.IsPencilNumberButton(text) {
		r.questionEditSvc.HandleQuestionNumber(userID, update, userState, text)
		return
	}

	switch text {
	case buttons.BtnBack:
		r.questionEditSvc.HandleBack(userID, update, userState)
	case buttons.BtnEditQuestionText:
		r.questionEditSvc.HandleEditQuestionText(userID, update, userState)
	case buttons.BtnEditQuestionType:
		r.questionEditSvc.HandleEditQuestionType(userID, update, userState)
	case buttons.BtnDeleteQuestion:
		r.questionEditSvc.HandleDeleteQuestion(userID, update, userState)
	case buttons.BtnYes:
		r.questionEditSvc.HandleConfirmDelete(userID, update, userState)
	case buttons.BtnNo:
		r.questionEditSvc.HandleCancelDelete(userID, update, userState)
	default:
		// Если текст не кнопка, обрабатываем ввод в зависимости от экрана
		r.handleUserInput(userID, update, userState, text)
	}
}

// handleUserInput обрабатывает текстовый ввод
func (r *QuestionEditRoutes) handleUserInput(userID int64, update tgbotapi.Update, userState *state.UserState, text string) {
	currentScreen := userState.GetCurrentScreen()

	switch currentScreen {
	case "edit-question-text":
		r.questionEditSvc.HandleNewQuestionTextInput(userID, update, userState, text)
	case "edit-question-type":
		r.questionEditSvc.HandleQuestionTypeSelection(userID, update, userState, text)
	default:
		// Игнорируем ввод на других экранах
		r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\routes\question_routes.go ===
package routes

import (
	"log"

	"telegram-bot/internal/buttons"
	"telegram-bot/internal/services/question"
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/state"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

type QuestionRoutes struct {
	questionSvc *question.QuestionService
	screenSvc   *screen.ScreenService
}

func NewQuestionRoutes(questionSvc *question.QuestionService, screenSvc *screen.ScreenService) *QuestionRoutes {
	return &QuestionRoutes{
		questionSvc: questionSvc,
		screenSvc:   screenSvc,
	}
}

func (r *QuestionRoutes) Route(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	log.Printf("[QuestionRoutes] 👤 UserID: %d | 💬 Текст: %s | Экран: %s", userID, text, userState.GetCurrentScreen())

	switch text {
	case buttons.BtnBack:
		r.questionSvc.HandleBack(userID, update, userState)
	case buttons.BtnCompliance:
		r.questionSvc.HandleCompliance(userID, update, userState)
	case buttons.BtnSingleChoice:
		r.questionSvc.HandleSingleChoice(userID, update, userState)
	case buttons.BtnMultipleChoice:
		r.questionSvc.HandleMultipleChoice(userID, update, userState)
	case buttons.BtnTextAnswer:
		r.questionSvc.HandleTextAnswer(userID, update, userState)
	default:
		// Любой другой текст - это ввод текста вопроса
		r.questionSvc.HandleQuestionTextInput(userID, update, userState, text)
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\routes\simple_checklist_routes.go ===
package routes

import (
	"log"

	"telegram-bot/internal/buttons"
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/services/simple_checklist"
	"telegram-bot/internal/state_manager/state"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// SimpleChecklistRoutes содержит методы для маршрутизации простых чек-листов
type SimpleChecklistRoutes struct {
	simpleChecklistSvc *simple_checklist.SimpleChecklistService
	screenSvc          *screen.ScreenService
}

func NewSimpleChecklistRoutes(simpleChecklistSvc *simple_checklist.SimpleChecklistService, screenSvc *screen.ScreenService) *SimpleChecklistRoutes {
	return &SimpleChecklistRoutes{
		simpleChecklistSvc: simpleChecklistSvc,
		screenSvc:          screenSvc,
	}
}

// Route маршрутизирует сообщение в контексте простых чек-листов
func (r *SimpleChecklistRoutes) Route(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	currentScreen := userState.GetCurrentScreen()

	log.Printf("[SimpleChecklistRoutes] 👤 UserID: %d | 💬 Текст: %s | Экран: %s", userID, text, currentScreen)

	// Маршрутизация по экранам
	switch currentScreen {
	case "create-simple-checklist-name":
		r.handleCreateNameScreen(userID, update, text, userState)
	case "simple-checklist-editor",
		"block-checklist-editor",
		"edit-checklist-title",
		"checklist-preview",
		"confirm-exit-to-main-menu":
		r.handleEditorScreen(userID, update, text, userState)
	default:
		r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	}
}

// handleCreateNameScreen обрабатывает экран создания названия
func (r *SimpleChecklistRoutes) handleCreateNameScreen(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	switch text {
	case buttons.BtnBack:
		r.simpleChecklistSvc.HandleCancelCreateSimpleChecklistName(userID, update, userState)
	default:
		r.simpleChecklistSvc.HandleCreateSimpleChecklistName(userID, update, userState, text)
	}
}

// handleEditorScreen обрабатывает экраны редактора
func (r *SimpleChecklistRoutes) handleEditorScreen(userID int64, update tgbotapi.Update, text string, userState *state.UserState) {
	currentScreen := userState.GetCurrentScreen()

	switch text {
	case buttons.BtnBackToMainMenu:
		// Переходим к подтверждению выхода
		r.simpleChecklistSvc.HandleConfirmExit(userID, update, userState)
	case buttons.BtnAddQuestion:
		r.simpleChecklistSvc.HandleBtnAddQuestion(userID, update, userState)
	case buttons.BtnEditTitleChecklist:
		// Начало редактирования названия
		r.simpleChecklistSvc.HandleEditTitle(userID, update, userState)
	case buttons.BtnEditQuestionChecklist:
		// Редактирование вопросов
		r.simpleChecklistSvc.HandleEditQuestions(userID, update, userState)
	case buttons.BtnPreview:
		// Превью чек-листа
		r.simpleChecklistSvc.HandlePreview(userID, update, userState)
	case buttons.BtnBack:
		// Обработка кнопки "Назад"
		r.simpleChecklistSvc.HandleBack(userID, update, userState)
	case buttons.BtnSaveDraft:
		// Сохранение черновика из превью
		r.simpleChecklistSvc.HandleSaveDraft(userID, update, userState)
	case buttons.BtnSavePublish:
		// Сохранение и публикация из превью
		r.simpleChecklistSvc.HandleSavePublish(userID, update, userState)
	case buttons.BtnYes:
		// Подтверждение выхода в главное меню
		r.simpleChecklistSvc.HandleConfirmExitYes(userID, update, userState)
	case buttons.BtnNo:
		// Отмена выхода в главное меню
		r.simpleChecklistSvc.HandleConfirmExitNo(userID, update, userState)
	default:
		// Если находимся в режиме редактирования названия - обрабатываем ввод нового названия
		if currentScreen == "edit-checklist-title" {
			r.simpleChecklistSvc.HandleNewTitleInput(userID, update, userState, text)
		} else {
			r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
		}
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\screens.go ===
package screens

import (
	"telegram-bot/internal/screens/configs"
	"telegram-bot/internal/screens/keyboards"
	"telegram-bot/internal/state_manager/state"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Инициализация конфигураций при первом импорте
func init() {
	configs.Init()
}

// GetKeyboardForState возвращает клавиатуру для текущего состояния пользователя
func GetKeyboardForState(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	if state == nil {
		// Если состояние nil, возвращаем клавиатуру авторизации
		config, exists := configs.ScreenConfigs["authorize-admin"]
		if !exists {
			// fallback
			return keyboards.GetAuthKeyboard(nil)
		}
		return config.Keyboard(nil)
	}

	// Получаем текущий экран из breadcrumbs
	currentScreen := state.GetCurrentScreen()
	if currentScreen == "" {
		// Если нет текущего экрана, возвращаем клавиатуру авторизации
		config, exists := configs.ScreenConfigs["authorize-admin"]
		if !exists {
			return keyboards.GetAuthKeyboard(state)
		}
		return config.Keyboard(state)
	}

	// Ищем конфигурацию для текущего экрана
	config, exists := configs.ScreenConfigs[currentScreen]
	if !exists {
		// Если экран не найден в конфигах, возвращаем клавиатуру авторизации
		config, _ := configs.ScreenConfigs["authorize-admin"]
		return config.Keyboard(state)
	}

	// Возвращаем клавиатуру для текущего экрана
	return config.Keyboard(state)
}

// GetMessageForScreen возвращает сообщение для экрана
func GetMessageForScreen(screen string, state *state.UserState) string {
	config, exists := configs.ScreenConfigs[screen]
	if !exists {
		// Возвращаем сообщение для экрана авторизации
		config, exists := configs.ScreenConfigs["authorize-admin"]
		if !exists {
			return "Привет! Выберите действие:"
		}
		return config.Message(state)
	}
	return config.Message(state)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\configs\configs.go ===
package configs

import (
	"telegram-bot/internal/state_manager/state"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// ScreenConfig - конфигурация экрана
type ScreenConfig struct {
	Keyboard func(state *state.UserState) tgbotapi.ReplyKeyboardMarkup
	Message  func(state *state.UserState) string
}

// ScreenConfigs - глобальная карта конфигураций экранов
var ScreenConfigs = map[string]ScreenConfig{}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\configs\registry.go ===
package configs

import (
	"telegram-bot/internal/screens/keyboards"
	"telegram-bot/internal/screens/messages"
)

// Init регистрирует все конфигурации экранов
func Init() {
	// ========== ЭКРАНЫ АВТОРИЗАЦИИ И МЕНЮ ==========
	ScreenConfigs["authorize-admin"] = ScreenConfig{
		Keyboard: keyboards.GetAuthKeyboard,
		Message:  messages.AuthMessage,
	}

	ScreenConfigs["admin-menu"] = ScreenConfig{
		Keyboard: keyboards.GetAdminMenu,
		Message:  messages.AdminMenuMessage,
	}

	// ========== ЭКРАНЫ ДЛЯ ОПУБЛИКОВАННЫХ/ОТМЕНЕННЫХ ЧЕК-ЛИСТОВ ==========
	ScreenConfigs["published-checklists-list"] = ScreenConfig{
		Keyboard: keyboards.GetPublishedChecklistsKeyboard,
		Message:  messages.PublishedChecklistsListMessage,
	}

	ScreenConfigs["published-checklist-detail"] = ScreenConfig{
		Keyboard: keyboards.GetPublishedChecklistDetailKeyboard,
		Message:  messages.PublishedChecklistDetailMessage,
	}

	// ========== ЭКРАНЫ ДЛЯ МОИХ ЧЕК-ЛИСТОВ ==========
	ScreenConfigs["my-checklists-list"] = ScreenConfig{
		Keyboard: keyboards.GetMyChecklistsKeyboard,
		Message:  messages.MyChecklistsListMessage,
	}

	ScreenConfigs["checklist-detail"] = ScreenConfig{
		Keyboard: keyboards.GetChecklistDetailKeyboard,
		Message:  messages.ChecklistDetailMessage,
	}

	ScreenConfigs["confirm-delete-checklist"] = ScreenConfig{
		Keyboard: keyboards.GetConfirmationKeyboard,
		Message:  messages.ConfirmDeleteChecklistMessage,
	}

	// ========== ЭКРАНЫ ДЛЯ СОЗДАНИЯ ПРОСТЫХ ЧЕК-ЛИСТОВ ==========
	ScreenConfigs["create-simple-checklist-name"] = ScreenConfig{
		Keyboard: keyboards.GetBackKeyboard,
		Message:  messages.CreateSimpleChecklistNameMessage,
	}

	ScreenConfigs["simple-checklist-editor"] = ScreenConfig{
		Keyboard: keyboards.GetChecklistSimpleEditorKeyboard,
		Message:  messages.SimpleChecklistEditorMessage,
	}

	// ========== ЭКРАНЫ ДЛЯ СОЗДАНИЯ ЧЕК-ЛИСТОВ С БЛОКАМИ ==========
	ScreenConfigs["create-block-checklist-name"] = ScreenConfig{
		Keyboard: keyboards.GetBackKeyboard,
		Message:  messages.CreateBlockChecklistNameMessage,
	}

	ScreenConfigs["block-checklist-editor"] = ScreenConfig{
		Keyboard: keyboards.GetChecklistBlockEditorKeyboard,
		Message:  messages.BlockChecklistEditorMessage,
	}

	ScreenConfigs["edit-block-name"] = ScreenConfig{
		Keyboard: keyboards.GetEditBlockNameKeyboard,
		Message:  messages.EditBlockNameMessage,
	}

	ScreenConfigs["block-editor"] = ScreenConfig{
		Keyboard: keyboards.GetBlockEditorKeyboard,
		Message:  messages.BlockEditorMessage,
	}

	ScreenConfigs["confirm-exit-block-checklist"] = ScreenConfig{
		Keyboard: keyboards.GetConfirmationKeyboard,
		Message:  messages.ConfirmExitBlockChecklistMessage,
	}

	// ========== ЭКРАНЫ ДЛЯ СОЗДАНИЯ ВОПРОСОВ ==========
	ScreenConfigs["select-question-type"] = ScreenConfig{
		Keyboard: keyboards.GetQuestionTypeKeyboard,
		Message:  messages.SelectQuestionTypeMessage,
	}

	ScreenConfigs["enter-question-text"] = ScreenConfig{
		Keyboard: keyboards.GetBackKeyboard,
		Message:  messages.EnterQuestionTextMessage,
	}

	ScreenConfigs["enter-answer-options"] = ScreenConfig{
		Keyboard: keyboards.GetBackKeyboard,
		Message:  messages.EnterAnswerOptionsMessage,
	}

	ScreenConfigs["select-correct-answers"] = ScreenConfig{
		Keyboard: keyboards.GetBackKeyboard,
		Message:  messages.SelectCorrectAnswersMessage,
	}

	// ========== ЭКРАНЫ РЕДАКТИРОВАНИЯ ==========
	ScreenConfigs["edit-checklist-title"] = ScreenConfig{
		Keyboard: keyboards.GetBackKeyboard,
		Message:  messages.EditChecklistTitleMessage,
	}

	ScreenConfigs["view-question"] = ScreenConfig{
		Keyboard: keyboards.GetQuestionListKeyboard,
		Message:  messages.ViewQuestionMessage,
	}

	ScreenConfigs["edit-question-text"] = ScreenConfig{
		Keyboard: keyboards.GetBackKeyboard,
		Message:  messages.EditQuestionTextMessage,
	}

	ScreenConfigs["edit-question-type"] = ScreenConfig{
		Keyboard: keyboards.GetQuestionTypeKeyboard,
		Message:  messages.EditQuestionTypeMessage,
	}

	ScreenConfigs["confirm-delete-question"] = ScreenConfig{
		Keyboard: keyboards.GetConfirmationKeyboard,
		Message:  messages.ConfirmDeleteQuestionMessage,
	}

	// ========== ЭКРАНЫ ПРЕВЬЮ ==========
	ScreenConfigs["checklist-preview"] = ScreenConfig{
		Keyboard: keyboards.GetChecklistPreviewKeyboard,
		Message:  messages.ChecklistPreviewMessage,
	}

	// ========== ЭКРАНЫ ПОДТВЕРЖДЕНИЯ ==========
	ScreenConfigs["confirm-exit-to-main-menu"] = ScreenConfig{
		Keyboard: keyboards.GetConfirmationKeyboard,
		Message:  messages.ConfirmExitToMainMenuMessage,
	}

	// ========== ЭКРАНЫ ДЛЯ БЛОКОВ ==========
	ScreenConfigs["block-view-questions"] = ScreenConfig{
		Keyboard: keyboards.GetBlockQuestionsKeyboard,
		Message:  messages.BlockViewQuestionsMessage,
	}

	ScreenConfigs["edit-question-detail"] = ScreenConfig{
		Keyboard: keyboards.GetQuestionDetailKeyboard,
		Message:  messages.EditQuestionDetailMessage,
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\formatters\checklist_formatter.go ===
package formatters

import (
	"telegram-bot/internal/formatters"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"
)

// FormatChecklistPreview форматирует чек-лист для превью
func FormatChecklistPreview(state *state.UserState) string {
	if state == nil || !state.HasCheckList() {
		return "❌ Чек-лист не найден"
	}

	checklistData := state.CurrentCheckList

	switch checklist := checklistData.(type) {
	case *types.SimpleCheckList:
		return formatters.FormatSimpleChecklistPreview(checklist)
	case *types.BlockedCheckList:
		return formatters.FormatBlockedChecklistPreview(checklist)
	default:
		return "❌ Неизвестный тип чек-листа"
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\keyboards\block_keyboards.go ===
package keyboards

import (
	"fmt"
	"strconv"
	"telegram-bot/internal/buttons"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// GetChecklistBlockEditorKeyboard - основная клавиатура редактора блоков (показывает блоки + действия)
func GetChecklistBlockEditorKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	// Если нет чек-листа или он не блокированный - возвращаем базовую клавиатуру
	if state == nil || !state.HasCheckList() {
		return getBaseBlockActionsKeyboard()
	}

	checklistData, ok := state.CurrentCheckList.(*types.BlockedCheckList)
	if !ok {
		return getBaseBlockActionsKeyboard()
	}

	// Если нет блоков - показываем только кнопки действий
	if len(checklistData.Blocks) == 0 {
		return getBaseBlockActionsKeyboard()
	}

	var rows [][]tgbotapi.KeyboardButton

	// Добавляем кнопки блоков
	for i, block := range checklistData.Blocks {
		// Форматируем текст кнопки блока
		buttonText := formatBlockButton(&block, i+1)
		row := []tgbotapi.KeyboardButton{tgbotapi.NewKeyboardButton(buttonText)}
		rows = append(rows, row)
	}

	// Добавляем разделительную пустую строку
	rows = append(rows, []tgbotapi.KeyboardButton{})

	// Добавляем кнопки действий
	rows = append(rows, []tgbotapi.KeyboardButton{
		tgbotapi.NewKeyboardButton(buttons.BtnAddBlock),
		tgbotapi.NewKeyboardButton(buttons.BtnPreview),
	})

	// Добавляем кнопку редактирования названия чек-листа
	rows = append(rows, []tgbotapi.KeyboardButton{
		tgbotapi.NewKeyboardButton(buttons.BtnEditTitleChecklist),
	})

	rows = append(rows, []tgbotapi.KeyboardButton{
		tgbotapi.NewKeyboardButton(buttons.BtnBackToMainMenu),
	})

	return tgbotapi.NewReplyKeyboard(rows...)
}

// GetBlockEditorKeyboard - клавиатура редактора конкретного блока
func GetBlockEditorKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	// Проверяем, есть ли вопросы в текущем блоке
	hasQuestions := false
	if state != nil && state.HasCheckList() {
		if checklistData, ok := state.CurrentCheckList.(*types.BlockedCheckList); ok {
			if blockIdx, ok := state.Data["current_block_index"].(int); ok {
				if blockIdx >= 0 && blockIdx < len(checklistData.Blocks) {
					hasQuestions = len(checklistData.Blocks[blockIdx].Questions) > 0
				}
			}
		}
	}

	if hasQuestions {
		// Есть вопросы - показываем все кнопки
		return tgbotapi.NewReplyKeyboard(
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnAddQuestion),
				tgbotapi.NewKeyboardButton(buttons.BtnEditTitleBlockChecklist),
			),
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnEditQuestionChecklist),
				tgbotapi.NewKeyboardButton(buttons.BtnPreviewBlock),
			),
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnBackToBlockList),
			),
		)
	} else {
		// Нет вопросов - скрываем кнопки редактирования вопросов и превью блока
		return tgbotapi.NewReplyKeyboard(
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnAddQuestion),
				tgbotapi.NewKeyboardButton(buttons.BtnEditTitleBlockChecklist),
			),
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnBackToBlockList),
			),
		)
	}
}

// GetEditBlockNameKeyboard - клавиатура для ввода/редактирования названия блока
func GetEditBlockNameKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	return tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnBack), //BtnCancel
		),
	)
}

// formatBlockButton - форматирует текст кнопки блока
func formatBlockButton(block *types.Block, number int) string {
	questionCount := len(block.Questions)
	var emoji string
	// Выбираем эмодзи в зависимости от количества вопросов
	switch {
	case questionCount == 0:
		emoji = "📭" // пустой блок
	case questionCount < 5:
		emoji = "🧱" // обычный блок
	default:
		emoji = "🏗️" // большой блок
	}
	name := block.Name
	return fmt.Sprintf("%s %d. %s (%d)", emoji, number, name, questionCount)
}

// getBaseBlockActionsKeyboard - базовая клавиатура действий (когда нет блоков)
func getBaseBlockActionsKeyboard() tgbotapi.ReplyKeyboardMarkup {
	return tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnAddBlock),
			tgbotapi.NewKeyboardButton(buttons.BtnPreview),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnEditTitleChecklist),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnBackToMainMenu),
		),
	)
}

// GetBlockQuestionsKeyboard - клавиатура для списка вопросов в блоке
func GetBlockQuestionsKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	// Проверяем наличие чек-листа и блока
	if state == nil || !state.HasCheckList() {
		return GetBackKeyboard(state)
	}

	checklistData, ok := state.CurrentCheckList.(*types.BlockedCheckList)
	if !ok {
		return GetBackKeyboard(state)
	}

	// Получаем индекс текущего блока
	blockIdx, ok := state.Data["current_block_index"].(int)
	if !ok {
		return GetBackKeyboard(state)
	}

	if blockIdx < 0 || blockIdx >= len(checklistData.Blocks) {
		return GetBackKeyboard(state)
	}

	block := checklistData.Blocks[blockIdx]
	total := len(block.Questions)
	if total == 0 {
		return GetBackKeyboard(state)
	}

	// Создаем кнопки с карандашом и номером
	var rows [][]tgbotapi.KeyboardButton

	// Добавляем кнопки вопросов по 3 в ряд
	for i := 0; i < total; i++ {
		if i%3 == 0 {
			// Начинаем новую строку
			row := []tgbotapi.KeyboardButton{}

			// Добавляем до 3 кнопок в текущую строку
			for j := 0; j < 3 && i+j < total; j++ {
				questionNumber := i + j + 1
				// Создаем кнопку с карандашом и номером: ✏️ 1, ✏️ 2 и т.д.
				buttonText := "✏️ " + strconv.Itoa(questionNumber)
				row = append(row, tgbotapi.NewKeyboardButton(buttonText))
			}

			rows = append(rows, row)
		}
	}

	// Кнопка возврата
	rows = append(rows, []tgbotapi.KeyboardButton{
		tgbotapi.NewKeyboardButton(buttons.BtnBack),
	})

	return tgbotapi.NewReplyKeyboard(rows...)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\keyboards\checklist_keyboards.go ===
package keyboards

import (
	"telegram-bot/internal/buttons"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// GetChecklistSimpleEditorKeyboard - клавиатура редактора простого чек-листа
func GetChecklistSimpleEditorKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	// Проверяем, есть ли вопросы в текущем чек-листе
	hasQuestions := false
	if state != nil && state.CurrentCheckList != nil {
		if simpleChecklist, ok := state.CurrentCheckList.(*types.SimpleCheckList); ok {
			hasQuestions = len(simpleChecklist.Questions) > 0
		}
	}

	if hasQuestions {
		// Есть вопросы - показываем все кнопки
		return tgbotapi.NewReplyKeyboard(
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnAddQuestion),
				tgbotapi.NewKeyboardButton(buttons.BtnPreview),
			),
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnEditTitleChecklist),
				tgbotapi.NewKeyboardButton(buttons.BtnEditQuestionChecklist),
			),
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnBackToMainMenu),
			),
		)
	} else {
		// Нет вопросов - скрываем кнопку редактирования вопросов
		return tgbotapi.NewReplyKeyboard(
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnAddQuestion),
				tgbotapi.NewKeyboardButton(buttons.BtnPreview),
			),
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnEditTitleChecklist),
			),
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnBackToMainMenu),
			),
		)
	}
}

// GetChecklistPreviewKeyboard - клавиатура превью чек-листа
func GetChecklistPreviewKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	return tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnSaveDraft),
			tgbotapi.NewKeyboardButton(buttons.BtnSavePublish),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnBack),
		),
	)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\keyboards\checklist_list_keyboards.go ===
package keyboards

import (
	"strconv"
	"telegram-bot/internal/buttons"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/storage/models"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// GetMyChecklistsKeyboard - клавиатура для списка чек-листов с кнопками-номерами (как у вопросов)
func GetMyChecklistsKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	// Получаем список чек-листов из состояния
	checklists, ok := state.Data["my_checklists"].([]models.Checklist)
	if !ok || len(checklists) == 0 {
		// Если нет чек-листов - только кнопка назад
		return GetBackKeyboard(state)
	}

	var rows [][]tgbotapi.KeyboardButton

	// Создаем кнопки с карандашом и номером по 3 в ряд (как у вопросов)
	for i := 0; i < len(checklists); i++ {
		if i%3 == 0 {
			row := []tgbotapi.KeyboardButton{}

			// Добавляем до 3 кнопок в текущую строку
			for j := 0; j < 3 && i+j < len(checklists); j++ {
				checklistNumber := i + j + 1
				// Создаем кнопку с карандашом и номером: ✏️ 1, ✏️ 2 и т.д. (как у вопросов)
				buttonText := "✏️ " + strconv.Itoa(checklistNumber)
				row = append(row, tgbotapi.NewKeyboardButton(buttonText))
			}

			rows = append(rows, row)
		}
	}

	// Добавляем разделительную строку
	rows = append(rows, []tgbotapi.KeyboardButton{})

	// Кнопка возврата
	rows = append(rows, []tgbotapi.KeyboardButton{
		tgbotapi.NewKeyboardButton(buttons.BtnBack),
	})

	return tgbotapi.NewReplyKeyboard(rows...)
}

// GetChecklistDetailKeyboard - клавиатура для деталей чек-листа
func GetChecklistDetailKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	return tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnEditCheckList),
			tgbotapi.NewKeyboardButton(buttons.BtnPublishChecklist),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnDeleteCheckList),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnBack),
		),
	)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\keyboards\entry_keyboards.go ===
package keyboards

import (
	"telegram-bot/internal/buttons"
	"telegram-bot/internal/state_manager/state"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// GetAuthKeyboard возвращает клавиатуру авторизации
func GetAuthKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	return tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnAuth),
		),
	)
}

// GetAdminMenu возвращает главное меню администратора
func GetAdminMenu(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	return tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnCreateSimpleChecklist),
			tgbotapi.NewKeyboardButton(buttons.BtnCreateBlockChecklist),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnMyChecklists),
			tgbotapi.NewKeyboardButton(buttons.BtnPublished),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnCanceled),
			tgbotapi.NewKeyboardButton(buttons.BtnStatistics),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnLogout),
		),
	)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\keyboards\published_checklists_keyboards.go ===
package keyboards

import (
	"strconv"
	"telegram-bot/internal/buttons"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/storage/models"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// GetPublishedChecklistsKeyboard - клавиатура для списка опубликованных/отмененных чек-листов
func GetPublishedChecklistsKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	// Получаем список чек-листов из состояния
	checklists, ok := state.Data["published_checklists"].([]models.Checklist)
	if !ok || len(checklists) == 0 {
		// Если нет чек-листов - только кнопка назад
		return GetBackKeyboard(state)
	}

	var rows [][]tgbotapi.KeyboardButton

	// Создаем кнопки с карандашом и номером по 3 в ряд
	for i := 0; i < len(checklists); i++ {
		if i%3 == 0 {
			row := []tgbotapi.KeyboardButton{}

			// Добавляем до 3 кнопок в текущую строку
			for j := 0; j < 3 && i+j < len(checklists); j++ {
				checklistNumber := i + j + 1
				// Создаем кнопку с карандашом и номером: ✏️ 1, ✏️ 2 и т.д.
				buttonText := "✏️ " + strconv.Itoa(checklistNumber)
				row = append(row, tgbotapi.NewKeyboardButton(buttonText))
			}

			rows = append(rows, row)
		}
	}

	// Добавляем разделительную строку
	rows = append(rows, []tgbotapi.KeyboardButton{})

	// Кнопка возврата
	rows = append(rows, []tgbotapi.KeyboardButton{
		tgbotapi.NewKeyboardButton(buttons.BtnBack),
	})

	return tgbotapi.NewReplyKeyboard(rows...)
}

// GetPublishedChecklistDetailKeyboard - клавиатура для деталей опубликованного/отмененного чек-листа
func GetPublishedChecklistDetailKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	// Определяем тип чек-листа (published/unpublished)
	checklistType, ok := state.Data["current_checklist_type"].(string)
	if !ok {
		// fallback
		return GetBackKeyboard(state)
	}

	if checklistType == "published" {
		// Для опубликованных: снять с публикации + назад
		return tgbotapi.NewReplyKeyboard(
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnUnPublish),
			),
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnBack),
			),
		)
	} else {
		// Для отмененных: вернуть в публикацию + назад
		return tgbotapi.NewReplyKeyboard(
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnPublish),
			),
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton(buttons.BtnBack),
			),
		)
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\keyboards\question_edit_keyboards.go ===
package keyboards

import (
	"strconv"
	"telegram-bot/internal/buttons"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// GetQuestionListKeyboard - клавиатура для списка вопросов с кнопками выбора
func GetQuestionListKeyboard(userState *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	checklistData, ok := userState.CurrentCheckList.(*types.SimpleCheckList)
	if !ok {
		return GetBackKeyboard(userState)
	}

	total := len(checklistData.Questions)
	if total == 0 {
		return GetBackKeyboard(userState)
	}

	// Создаем кнопки с карандашом и номером
	var rows [][]tgbotapi.KeyboardButton

	// Добавляем кнопки вопросов по 3 в ряд
	for i := 0; i < total; i++ {
		if i%3 == 0 {
			// Начинаем новую строку
			row := []tgbotapi.KeyboardButton{}

			// Добавляем до 3 кнопок в текущую строку
			for j := 0; j < 3 && i+j < total; j++ {
				questionNumber := i + j + 1
				// Создаем кнопку с карандашом и номером: ✏️ 1, ✏️ 2 и т.д.
				buttonText := "✏️ " + strconv.Itoa(questionNumber)
				row = append(row, tgbotapi.NewKeyboardButton(buttonText))
			}

			rows = append(rows, row)
		}
	}

	// Кнопка возврата
	rows = append(rows, []tgbotapi.KeyboardButton{
		tgbotapi.NewKeyboardButton(buttons.BtnBack),
	})

	return tgbotapi.NewReplyKeyboard(rows...)
}

// GetQuestionDetailKeyboard - клавиатура для деталей вопроса
func GetQuestionDetailKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	return tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnEditQuestionText),
			tgbotapi.NewKeyboardButton(buttons.BtnEditQuestionType),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnDeleteQuestion),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnBack),
		),
	)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\keyboards\question_keyboards.go ===
package keyboards

import (
	"telegram-bot/internal/buttons"
	"telegram-bot/internal/state_manager/state"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// GetQuestionTypeKeyboard - клавиатура выбора типа вопроса (все в один столбик)
func GetQuestionTypeKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	return tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnCompliance),
			tgbotapi.NewKeyboardButton(buttons.BtnSingleChoice),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnMultipleChoice),
			tgbotapi.NewKeyboardButton(buttons.BtnTextAnswer),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnBack),
		),
	)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\keyboards\shared_keyboards.go ===
package keyboards

import (
	"telegram-bot/internal/buttons"
	"telegram-bot/internal/state_manager/state"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// GetConfirmationKeyboard - общая клавиатура подтверждения
func GetConfirmationKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	return tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnYes),
			tgbotapi.NewKeyboardButton(buttons.BtnNo),
		),
	)
}

func GetBackKeyboard(state *state.UserState) tgbotapi.ReplyKeyboardMarkup {
	return tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton(buttons.BtnBack),
		),
	)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\messages\auth_messages.go ===
package messages

import (
	"telegram-bot/internal/state_manager/state"
)

// AuthMessage - сообщение для экрана авторизации
func AuthMessage(state *state.UserState) string {
	return "👋 Привет! Я бот для управления чек-листами.\n\n" +
		"Для начала работы необходимо авторизоваться."
}

// AdminMenuMessage - сообщение для главного меню администратора
func AdminMenuMessage(state *state.UserState) string {
	if state != nil && state.User != nil {
		return "✅ Добро пожаловать, " + state.User.Username + " " + state.User.FullName + "!\n\nВыберите действие:"
	}
	return "Главное меню администратора. Выберите действие:"
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\messages\block_messages.go ===
package messages

import (
	"fmt"
	"strings"
	"telegram-bot/internal/formatters"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"
)

// EditBlockNameMessage - сообщение для ввода/редактирования названия блока
func EditBlockNameMessage(state *state.UserState) string {
	if blockIdx, ok := state.Data["current_block_index"].(int); ok {
		checklistData, _ := state.CurrentCheckList.(*types.BlockedCheckList)
		if blockIdx >= 0 && blockIdx < len(checklistData.Blocks) {
			currentName := checklistData.Blocks[blockIdx].Name
			return fmt.Sprintf("✏️ Редактирование названия блока\n\nТекущее название: %s\n\nВведите новое название:", currentName)
		}
	}
	return "Введите название нового блока:"
}

// BlockEditorMessage - сообщение для редактора блока
func BlockEditorMessage(state *state.UserState) string {
	blockIdx := state.Data["current_block_index"].(int)
	checklistData := state.CurrentCheckList.(*types.BlockedCheckList)
	block := checklistData.Blocks[blockIdx]
	questionCount := len(block.Questions)

	var statusEmoji string
	if questionCount == 0 {
		statusEmoji = "📭"
	} else if questionCount < 5 {
		statusEmoji = "🧱"
	} else {
		statusEmoji = "🏗️"
	}

	return fmt.Sprintf("%s Редактор блока: %s\n\n📊 Вопросов: %d\n\nВыберите действие:",
		statusEmoji, block.Name, questionCount)
}

// ConfirmExitBlockChecklistMessage - сообщение для подтверждения выхода из редактора блоков
func ConfirmExitBlockChecklistMessage(state *state.UserState) string {
	return "⚠️ ВНИМАНИЕ!\n\n" +
		"Вы собираетесь выйти из редактора чек-листа с блоками.\n\n" +
		"Все несохраненные изменения будут потеряны!\n\n" +
		"Вы уверены, что хотите выйти?"
}

// BlockViewQuestionsMessage - сообщение для списка вопросов в блоке
func BlockViewQuestionsMessage(state *state.UserState) string {
	checklistData := state.CurrentCheckList.(*types.BlockedCheckList)
	blockIdx := state.Data["current_block_index"].(int)
	block := checklistData.Blocks[blockIdx]
	total := len(block.Questions)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("📋 Список вопросов в блоке '%s' (%d шт.)\n\n", block.Name, total))

	for i, question := range block.Questions {
		sb.WriteString(fmt.Sprintf("%d. %s\n", i+1, question.Text))
		sb.WriteString(fmt.Sprintf("   (Тип: %s)\n\n", formatters.FormatQuestionType(question.Category)))
	}

	sb.WriteString("Выберите вопрос для редактирования:")
	return sb.String()
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\messages\checklist_list_messages.go ===
package messages

import (
	"fmt"
	"strings"
	"telegram-bot/internal/formatters"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/storage/models"
)

// MyChecklistsListMessage - сообщение для списка чек-листов
func MyChecklistsListMessage(state *state.UserState) string {
	checklists, ok := state.Data["my_checklists"].([]models.Checklist)
	if !ok || len(checklists) == 0 {
		return "📭 У вас пока нет черновиков чек-листов."
	}

	var sb strings.Builder
	sb.WriteString("📝 Ваши черновики чек-листов:\n\n")

	for i, checklist := range checklists {
		sb.WriteString(fmt.Sprintf("%d. %s\n", i+1, checklist.Name))
		sb.WriteString(fmt.Sprintf("   🏷️ ID: %d\n", checklist.ID))
		sb.WriteString(fmt.Sprintf("   📅 Создан: %s\n", checklist.CreatedAt.Format("02.01.2006 15:04")))
		sb.WriteString("\n")
	}

	sb.WriteString("Выберите чек-лист для работы:")

	return sb.String()
}

// ChecklistDetailMessage - сообщение для деталей чек-листа (ТЕПЕРЬ С ПРЕВЬЮ)
func ChecklistDetailMessage(state *state.UserState) string {
	checklist, ok := state.Data["current_checklist"].(*models.Checklist)
	if !ok || checklist == nil {
		return "❌ Чек-лист не найден"
	}

	questions, _ := state.Data["checklist_questions"].([]models.Question)
	answerOptions, _ := state.Data["checklist_answer_options"].([]models.AnswerOption)
	hasBlocks, _ := state.Data["has_blocks"].(bool)
	blocks, _ := state.Data["checklist_blocks"].([]models.QuestionBlock)
	templates, _ := state.Data["checklist_templates"].([]models.ChecklistTemplate)

	return formatters.FormatChecklist(checklist, hasBlocks, blocks, templates, questions, answerOptions)
}

// ConfirmDeleteChecklistMessage - сообщение для подтверждения удаления
func ConfirmDeleteChecklistMessage(state *state.UserState) string {
	checklist, ok := state.Data["current_checklist"].(*models.Checklist)
	if !ok || checklist == nil {
		return "❌ Чек-лист не найден"
	}

	return "🗑️ УДАЛЕНИЕ ЧЕК-ЛИСТА\n\n" +
		"Название: " + checklist.Name + "\n" +
		"ID: " + fmt.Sprintf("%d", checklist.ID) + "\n\n" +
		"⚠️ Внимание! Это действие нельзя отменить.\n" +
		"Все вопросы и ответы будут удалены.\n\n" +
		"Вы уверены, что хотите удалить этот чек-лист?"
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\messages\checklist_messages.go ===
package messages

import (
	"fmt"
	"telegram-bot/internal/screens/formatters"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"
)

// CreateSimpleChecklistNameMessage - сообщение для создания названия простого чек-листа
func CreateSimpleChecklistNameMessage(state *state.UserState) string {
	return "Введите название чек-листа:"
}

// CreateBlockChecklistNameMessage - сообщение для создания названия чек-листа с блоками
func CreateBlockChecklistNameMessage(state *state.UserState) string {
	return "Введите название чек-листа с блоками:"
}

// SimpleChecklistEditorMessage - сообщение для редактора простого чек-листа
func SimpleChecklistEditorMessage(state *state.UserState) string {
	if state != nil && state.HasCheckList() {
		return "Редактор чек-листа - " + state.CurrentCheckList.GetName()
	}
	return "Редактор чек-листа"
}

// BlockChecklistEditorMessage - сообщение для редактора чек-листа с блоками
func BlockChecklistEditorMessage(state *state.UserState) string {
	if state != nil && state.HasCheckList() {
		checklistData, ok := state.CurrentCheckList.(*types.BlockedCheckList)
		if ok {
			totalBlocks := len(checklistData.Blocks)
			totalQuestions := 0
			for _, block := range checklistData.Blocks {
				totalQuestions += len(block.Questions)
			}

			return fmt.Sprintf("🧱 Редактор чек-листа: %s\n\n📊 Статистика:\n• Блоков: %d\n• Вопросов: %d\n\nВыберите блок для редактирования или добавьте новый:",
				checklistData.Name, totalBlocks, totalQuestions)
		}
		return "Редактор чек-листа с блоками - " + state.CurrentCheckList.GetName()
	}
	return "Редактор чек-листа с блоками"
}

// EditChecklistTitleMessage - сообщение для редактирования названия чек-листа
func EditChecklistTitleMessage(state *state.UserState) string {
	currentName := ""
	if state != nil && state.CurrentCheckList != nil {
		currentName = state.CurrentCheckList.GetName()
	}

	return "✏️ Редактирование названия чек-листа\n\n" +
		"Текущее название: " + currentName + "\n\n" +
		"Введите новое название:"
}

// ChecklistPreviewMessage - сообщение для превью чек-листа
func ChecklistPreviewMessage(state *state.UserState) string {
	if state == nil || !state.HasCheckList() {
		return "❌ Чек-лист не найден"
	}

	return formatters.FormatChecklistPreview(state)
}

// ConfirmExitToMainMenuMessage - сообщение для подтверждения выхода
func ConfirmExitToMainMenuMessage(state *state.UserState) string {
	return "⚠️ ВНИМАНИЕ!\n\n" +
		"Вы собираетесь выйти из редактора чек-листа.\n\n" +
		"Все несохраненные изменения будут потеряны!\n\n" +
		"Вы уверены, что хотите выйти?"
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\messages\published_checklists_messages.go ===
package messages

import (
	"fmt"
	"strings"
	"telegram-bot/internal/formatters"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/storage/models"
)

// PublishedChecklistsListMessage - сообщение для списка опубликованных/отмененных чек-листов
func PublishedChecklistsListMessage(state *state.UserState) string {
	checklists, ok := state.Data["published_checklists"].([]models.Checklist)
	if !ok || len(checklists) == 0 {
		return "📭 Список чек-листов пуст."
	}

	checklistType, _ := state.Data["checklists_type"].(string)

	var sb strings.Builder

	if checklistType == "published" {
		sb.WriteString("🚀 Ваши опубликованные чек-листы:\n\n")
	} else {
		sb.WriteString("🚫 Ваши отмененные публикации:\n\n")
	}

	for i, checklist := range checklists {
		sb.WriteString(fmt.Sprintf("%d. %s\n", i+1, checklist.Name))
		sb.WriteString(fmt.Sprintf("   🏷️ ID: %d\n", checklist.ID))

		createdAt := checklist.CreatedAt
		if !createdAt.IsZero() && createdAt.Year() > 1 {
			sb.WriteString(fmt.Sprintf("   📅 Создан: %s\n", createdAt.Format("02.01.2006 15:04")))
		} else {
			sb.WriteString("   📅 Создан: (дата недоступна)\n")
		}

		sb.WriteString("\n")
	}

	sb.WriteString("Выберите чек-лист для работы:")

	return sb.String()
}

// PublishedChecklistDetailMessage - сообщение для деталей опубликованного/отмененного чек-листа
func PublishedChecklistDetailMessage(state *state.UserState) string {
	checklist, ok := state.Data["current_published_checklist"].(*models.Checklist)
	if !ok || checklist == nil {
		return "❌ Чек-лист не найден"
	}

	questions, _ := state.Data["published_checklist_questions"].([]models.Question)
	answerOptions, _ := state.Data["published_checklist_answer_options"].([]models.AnswerOption)
	hasBlocks, _ := state.Data["published_has_blocks"].(bool)
	blocks, _ := state.Data["published_checklist_blocks"].([]models.QuestionBlock)
	templates, _ := state.Data["published_checklist_templates"].([]models.ChecklistTemplate)

	return formatters.FormatChecklist(checklist, hasBlocks, blocks, templates, questions, answerOptions)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\screens\messages\question_messages.go ===
package messages

import (
	"fmt"
	"strings"
	"telegram-bot/internal/formatters"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"
)

// SelectQuestionTypeMessage - сообщение для выбора типа вопроса
func SelectQuestionTypeMessage(state *state.UserState) string {
	return "Выберите тип вопроса:\n\n" +
		"✅ Соответствие - Да/Нет\n" +
		"🔘 Одиночный выбор - Один правильный вариант из нескольких\n" +
		"☑️ Множественный выбор - Несколько правильных вариантов\n" +
		"📝 Текстовый ответ - Свободный текст"
}

// EnterQuestionTextMessage - сообщение для ввода текста вопроса
func EnterQuestionTextMessage(state *state.UserState) string {
	return "Введите текст вопроса:"
}

// EnterAnswerOptionsMessage - сообщение для ввода вариантов ответов
func EnterAnswerOptionsMessage(state *state.UserState) string {
	return "Введите варианты ответов (каждый с новой строки):\n\n" +
		"Пример:\n" +
		"Вариант 1\n" +
		"Вариант 2\n" +
		"Вариант 3"
}

// SelectCorrectAnswersMessage - сообщение для выбора правильных ответов
func SelectCorrectAnswersMessage(state *state.UserState) string {
	count, _ := state.Data["answer_options_count"].(int)
	if count < 2 {
		count = 2
	}

	questionTypeStr, _ := state.Data["selected_question_type"].(string)
	questionType := types.QuestionCategory(questionTypeStr)

	baseMessage := "Введите номера правильных ответов"
	availableOptions := "Доступные варианты: 1-" + fmt.Sprintf("%d", count)

	switch questionType {
	case types.CategorySingleChoice:
		return baseMessage + " (например: 1):\n\n" +
			availableOptions + "\n" +
			"🔘 Одиночный выбор: нужен ровно 1 правильный ответ"

	case types.CategoryMultipleChoice:
		return baseMessage + " (например: 1,3):\n\n" +
			availableOptions + "\n" +
			"☑️ Множественный выбор: нужно минимум 2 правильных ответа"

	default:
		return baseMessage + " (например: 1 или 1,3):\n\n" +
			availableOptions
	}
}

// ViewQuestionMessage - сообщение для просмотра списка вопросов
func ViewQuestionMessage(state *state.UserState) string {
	checklistData, _ := state.CurrentCheckList.(*types.SimpleCheckList)
	total := len(checklistData.Questions)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("📋 Список вопросов (%d шт.)\n\n", total))

	for i, question := range checklistData.Questions {
		sb.WriteString(fmt.Sprintf("%d. %s\n", i+1, question.Text))
		sb.WriteString(fmt.Sprintf("   (Тип: %s)\n\n", formatters.FormatQuestionType(question.Category)))
	}

	sb.WriteString("Выберите вопрос для редактирования:")
	return sb.String()
}

// EditQuestionTextMessage - сообщение для редактирования текста вопроса
func EditQuestionTextMessage(state *state.UserState) string {
	checklistData, _ := state.CurrentCheckList.(*types.SimpleCheckList)
	idx, _ := state.Data["edit_question_index"].(int)
	currentText := checklistData.Questions[idx].Text

	return "✏️ Редактирование текста вопроса\n\n" +
		"Текущий текст: " + currentText + "\n\n" +
		"Введите новый текст:"
}

// EditQuestionTypeMessage - сообщение для изменения типа вопроса
func EditQuestionTypeMessage(state *state.UserState) string {
	checklistData, _ := state.CurrentCheckList.(*types.SimpleCheckList)
	idx, _ := state.Data["edit_question_index"].(int)
	currentType := checklistData.Questions[idx].Category

	return "✏️ Изменение типа вопроса\n\n" +
		"Текущий тип: " + formatters.FormatQuestionType(currentType) + "\n\n" +
		"Выберите новый тип:"
}

// ConfirmDeleteQuestionMessage - сообщение для подтверждения удаления вопроса
func ConfirmDeleteQuestionMessage(state *state.UserState) string {
	var questionText string

	isBlockQuestion, _ := state.Data["is_edit_block_questions"].(bool)

	if isBlockQuestion {
		if blockedChecklist, ok := state.CurrentCheckList.(*types.BlockedCheckList); ok && blockedChecklist != nil {
			blockIdx, _ := state.Data["current_block_index"].(int)
			questionIdx, _ := state.Data["edit_question_index"].(int)

			if blockIdx >= 0 && blockIdx < len(blockedChecklist.Blocks) {
				block := blockedChecklist.Blocks[blockIdx]
				if questionIdx >= 0 && questionIdx < len(block.Questions) {
					questionText = block.Questions[questionIdx].Text
				}
			}
		}
	} else {
		if simpleChecklist, ok := state.CurrentCheckList.(*types.SimpleCheckList); ok && simpleChecklist != nil {
			idx, _ := state.Data["edit_question_index"].(int)
			if idx >= 0 && idx < len(simpleChecklist.Questions) {
				questionText = simpleChecklist.Questions[idx].Text
			}
		}
	}

	if questionText == "" {
		questionText = "(текст вопроса недоступен)"
	}

	return "🗑️ Удаление вопроса\n\n" +
		"Текст вопроса: " + questionText + "\n\n" +
		"Вы уверены что хотите удалить этот вопрос?\n" +
		"Это действие нельзя отменить."
}

// EditQuestionDetailMessage - сообщение для деталей вопроса
func EditQuestionDetailMessage(state *state.UserState) string {
	isBlockQuestion, _ := state.Data["is_edit_block_questions"].(bool)

	if isBlockQuestion {
		checklistData, ok := state.CurrentCheckList.(*types.BlockedCheckList)
		if !ok {
			return "❌ Ошибка: неверный тип чек-листа для редактирования вопроса в блоке"
		}

		blockIdx, ok := state.Data["current_block_index"].(int)
		if !ok {
			return "❌ Ошибка: блок не выбран"
		}

		questionIdx, ok := state.Data["edit_question_index"].(int)
		if !ok {
			return "❌ Ошибка: вопрос не выбран"
		}

		if blockIdx < 0 || blockIdx >= len(checklistData.Blocks) {
			return "❌ Ошибка: неверный индекс блока"
		}

		block := checklistData.Blocks[blockIdx]

		if questionIdx < 0 || questionIdx >= len(block.Questions) {
			return "❌ Ошибка: неверный индекс вопроса"
		}

		question := block.Questions[questionIdx]

		message := fmt.Sprintf("🧱 Редактирование вопроса в блоке '%s'\n\n", block.Name)
		message += fmt.Sprintf("📝 Текст: %s\n", question.Text)
		message += fmt.Sprintf("🎯 Тип: %s\n", formatters.FormatQuestionType(question.Category))

		if len(question.AnswerOptions) > 0 {
			message += "\n📊 Варианты ответов:\n"
			for i, opt := range question.AnswerOptions {
				correctMark := " "
				if opt.IsCorrect {
					correctMark = "✅"
				}
				message += fmt.Sprintf("%s %d. %s\n", correctMark, i+1, opt.Text)
			}
		} else {
			message += "\n⚠️ Нет вариантов ответов"
		}

		message += "\n\nВыберите действие для редактирования:"
		return message
	} else {
		checklistData, ok := state.CurrentCheckList.(*types.SimpleCheckList)
		if !ok {
			return "❌ Ошибка: неверный тип чек-листа"
		}

		idx, ok := state.Data["edit_question_index"].(int)
		if !ok {
			return "❌ Ошибка: вопрос не выбран"
		}

		if idx < 0 || idx >= len(checklistData.Questions) {
			return "❌ Ошибка: неверный индекс вопроса"
		}

		question := checklistData.Questions[idx]

		message := fmt.Sprintf("✏️ Редактирование вопроса №%d/%d:\n\n", idx+1, len(checklistData.Questions))
		message += fmt.Sprintf("📝 Текст: %s\n", question.Text)
		message += fmt.Sprintf("🎯 Тип: %s\n", formatters.FormatQuestionType(question.Category))

		if len(question.AnswerOptions) > 0 {
			message += "\n📊 Варианты ответов:\n"
			for i, opt := range question.AnswerOptions {
				correctMark := " "
				if opt.IsCorrect {
					correctMark = "✅"
				}
				message += fmt.Sprintf("%s %d. %s\n", correctMark, i+1, opt.Text)
			}
		} else {
			message += "\n⚠️ Нет вариантов ответов"
		}

		message += "\n\nВыберите действие для редактирования:"
		return message
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\answers\handlers.go ===
package answers

import (
	"strings"

	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// HandleAnswerOptionsInput обрабатывает ввод вариантов ответов
func (s *AnswersService) HandleAnswerOptionsInput(userID int64, update tgbotapi.Update, userState *state.UserState, text string) {
	options := strings.Split(text, "\n")
	cleanOptions := make([]string, 0)

	for _, opt := range options {
		if trimmed := strings.TrimSpace(opt); trimmed != "" {
			cleanOptions = append(cleanOptions, trimmed)
		}
	}

	if len(cleanOptions) < 2 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Нужно минимум 2 варианта")
		return
	}

	err := s.addAnswerOptions(userID, cleanOptions)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ "+err.Error())
		return
	}

	s.stateMgr.NavigateTo(userID, "select-correct-answers")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleCorrectAnswersInput обрабатывает выбор правильных ответов
func (s *AnswersService) HandleCorrectAnswersInput(userID int64, update tgbotapi.Update, userState *state.UserState, text string) {
	indices, err := s.parseIndices(text)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ "+err.Error())
		return
	}

	// Определяем индекс вопроса
	var idx int
	if lastIdx, err := s.questionSvc.GetLastQuestionIndex(userID); err == nil {
		idx = lastIdx
	} else {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ "+err.Error())
		return
	}

	// Проверяем тип чек-листа и категорию вопроса
	checklistData, exists := s.stateMgr.GetCheckList(userID)
	if exists {
		// Определяем категорию вопроса
		var category types.QuestionCategory
		isBlockMode, _ := userState.Data["is_block_mode"].(bool)

		if isBlockMode {
			// Для блоков
			if checklist, ok := checklistData.(*types.BlockedCheckList); ok {
				blockIdx, _ := userState.Data["current_block_index"].(int)
				if blockIdx >= 0 && blockIdx < len(checklist.Blocks) &&
					idx >= 0 && idx < len(checklist.Blocks[blockIdx].Questions) {
					category = checklist.Blocks[blockIdx].Questions[idx].Category
				}
			}
		} else {
			// Для простых чек-листов
			if simpleChecklist, ok := checklistData.(*types.SimpleCheckList); ok && idx >= 0 && idx < len(simpleChecklist.Questions) {
				category = simpleChecklist.Questions[idx].Category
			}
		}

		// Проверяем валидность количества ответов для типа вопроса
		if category == types.CategorySingleChoice && len(indices) != 1 {
			s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Для одиночного выбора нужен 1 правильный ответ")
			return
		}

		if category == types.CategoryMultipleChoice && len(indices) < 1 {
			s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Для множественного выбора нужен хотя бы 1 правильный ответ")
			return
		}
	}

	err = s.setCorrectAnswers(userID, indices, idx)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ "+err.Error())
		return
	}

	// Завершаем процесс создания/редактирования вопроса
	s.completeQuestionProcess(userID, update, userState)
}

// HandleBack обрабатывает кнопку "Назад" для ответов
func (s *AnswersService) HandleBack(userID int64, update tgbotapi.Update, userState *state.UserState) {
	currentScreen := userState.GetCurrentScreen()

	switch currentScreen {
	case "enter-answer-options":
		s.stateMgr.NavigateTo(userID, "enter-question-text")
	case "select-correct-answers":
		s.stateMgr.NavigateTo(userID, "enter-answer-options")
	default:
		// Проверяем режим: блок или простой чек-лист
		isBlockMode, _ := userState.Data["is_block_mode"].(bool)

		if isBlockMode {
			// Возвращаемся в редактор блока
			delete(userState.Data, "is_block_mode")
			delete(userState.Data, "selected_question_type")
			s.stateMgr.SetState(userID, userState)
			s.stateMgr.NavigateTo(userID, "block-editor")
		} else {
			// Проверяем режим: создание или редактирование
			if isEdit, ok := userState.Data["is_edit_mode"].(bool); ok && isEdit {
				// Возвращаемся к деталям вопроса при редактировании
				delete(userState.Data, "is_edit_mode")
				delete(userState.Data, "edit_question_position")
				delete(userState.Data, "selected_question_type")
				s.stateMgr.SetState(userID, userState)
				s.stateMgr.NavigateTo(userID, "edit-question-detail")
			} else {
				// Возвращаемся к выбору типа вопроса при создании
				delete(userState.Data, "selected_question_type")
				s.stateMgr.SetState(userID, userState)
				s.stateMgr.NavigateTo(userID, "select-question-type")
			}
		}
	}

	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleUserInput обрабатывает ввод пользователя для ответов
func (s *AnswersService) HandleUserInput(userID int64, update tgbotapi.Update, userState *state.UserState, text string) {
	currentScreen := userState.GetCurrentScreen()

	switch currentScreen {
	case "enter-answer-options":
		s.HandleAnswerOptionsInput(userID, update, userState, text)
	case "select-correct-answers":
		s.HandleCorrectAnswersInput(userID, update, userState, text)
	default:
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\answers\helpers.go ===
package answers

import (
	"fmt"
	"log"
	"strconv"
	"strings"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// addAnswerOptions добавляет варианты ответов для нового вопроса
func (s *AnswersService) addAnswerOptions(userID int64, options []string) error {
	idx, err := s.questionSvc.GetLastQuestionIndex(userID)
	if err != nil {
		return err
	}

	checklistData, exists := s.stateMgr.GetCheckList(userID)
	if !exists {
		return fmt.Errorf("чек-лист не найден")
	}

	// Проверяем режим: блок или простой чек-лист
	userState, _ := s.stateMgr.GetState(userID)
	isBlockMode, _ := userState.Data["is_block_mode"].(bool)
	isEditBlockQuestion, _ := userState.Data["is_edit_block_questions"].(bool)

	if isBlockMode || isEditBlockQuestion {
		// ДЛЯ БЛОКОВ (создание или редактирование)
		blockedChecklist, ok := checklistData.(*types.BlockedCheckList)
		if !ok {
			return fmt.Errorf("неверный тип чек-листа для режима блока")
		}

		blockIdx, ok := userState.Data["current_block_index"].(int)
		if !ok {
			return fmt.Errorf("блок не выбран")
		}

		if blockIdx < 0 || blockIdx >= len(blockedChecklist.Blocks) {
			return fmt.Errorf("неверный индекс блока")
		}

		if idx < 0 || idx >= len(blockedChecklist.Blocks[blockIdx].Questions) {
			return fmt.Errorf("неверный индекс вопроса")
		}

		question := &blockedChecklist.Blocks[blockIdx].Questions[idx]

		// Очищаем старые варианты и добавляем новые
		question.AnswerOptions = make([]types.AnswerOption, 0, len(options))
		for _, opt := range options {
			question.AnswerOptions = append(question.AnswerOptions, types.NewAnswerOption(opt, false))
		}

		// Сохраняем количество вариантов
		userState.Data["answer_options_count"] = len(options)
		s.stateMgr.SetState(userID, userState)

		log.Printf("[AnswersService] ✅ Добавлено %d вариантов для вопроса %d в блоке %d",
			len(options), idx+1, blockIdx+1)
	} else {
		// ДЛЯ ПРОСТЫХ ЧЕК-ЛИСТОВ (существующая логика)
		simpleChecklist, ok := checklistData.(*types.SimpleCheckList)
		if !ok {
			return fmt.Errorf("неверный тип чек-листа")
		}

		if idx < 0 || idx >= len(simpleChecklist.Questions) {
			return fmt.Errorf("неверный индекс вопроса")
		}

		question := &simpleChecklist.Questions[idx]

		// Очищаем старые варианты и добавляем новые
		question.AnswerOptions = make([]types.AnswerOption, 0, len(options))
		for _, opt := range options {
			question.AnswerOptions = append(question.AnswerOptions, types.NewAnswerOption(opt, false))
		}

		// Сохраняем количество вариантов
		userState.Data["answer_options_count"] = len(options)
		s.stateMgr.SetState(userID, userState)

		log.Printf("[AnswersService] ✅ Добавлено %d вариантов для вопроса %d", len(options), idx+1)
	}

	return nil
}

// setCorrectAnswers устанавливает правильные ответы
func (s *AnswersService) setCorrectAnswers(userID int64, indices []int, questionIdx int) error {
	checklistData, exists := s.stateMgr.GetCheckList(userID)
	if !exists {
		return fmt.Errorf("чек-лист не найден")
	}

	// Проверяем режим: блок или простой чек-лист
	userState, _ := s.stateMgr.GetState(userID)
	isBlockMode, _ := userState.Data["is_block_mode"].(bool)
	isEditBlockQuestion, _ := userState.Data["is_edit_block_questions"].(bool)

	if isBlockMode || isEditBlockQuestion {
		// ДЛЯ БЛОКОВ
		blockedChecklist, ok := checklistData.(*types.BlockedCheckList)
		if !ok {
			return fmt.Errorf("неверный тип чек-листа для режима блока")
		}

		blockIdx, ok := userState.Data["current_block_index"].(int)
		if !ok {
			return fmt.Errorf("блок не выбран")
		}

		if blockIdx < 0 || blockIdx >= len(blockedChecklist.Blocks) {
			return fmt.Errorf("неверный индекс блока")
		}

		if questionIdx < 0 || questionIdx >= len(blockedChecklist.Blocks[blockIdx].Questions) {
			return fmt.Errorf("неверный индекс вопроса")
		}

		question := &blockedChecklist.Blocks[blockIdx].Questions[questionIdx]

		// Получаем количество вариантов
		count := len(question.AnswerOptions)

		// Проверка индексов
		for _, i := range indices {
			if i < 0 || i >= count {
				return fmt.Errorf("неверный индекс: %d", i+1)
			}
		}

		// Установка правильных ответов
		for i := range question.AnswerOptions {
			question.AnswerOptions[i].IsCorrect = false
		}
		for _, correctIdx := range indices {
			if correctIdx < len(question.AnswerOptions) {
				question.AnswerOptions[correctIdx].IsCorrect = true
			}
		}

		log.Printf("[AnswersService] ✅ Установлены правильные ответы: %v для вопроса %d в блоке %d",
			indices, questionIdx+1, blockIdx+1)
	} else {
		// ДЛЯ ПРОСТЫХ ЧЕК-ЛИСТОВ (существующая логика)
		simpleChecklist, ok := checklistData.(*types.SimpleCheckList)
		if !ok {
			return fmt.Errorf("неверный тип чек-листа")
		}

		if questionIdx < 0 || questionIdx >= len(simpleChecklist.Questions) {
			return fmt.Errorf("неверный индекс вопроса")
		}

		question := &simpleChecklist.Questions[questionIdx]

		// Получаем количество вариантов
		count := len(question.AnswerOptions)

		// Проверка индексов
		for _, i := range indices {
			if i < 0 || i >= count {
				return fmt.Errorf("неверный индекс: %d", i+1)
			}
		}

		// Установка правильных ответов
		for i := range question.AnswerOptions {
			question.AnswerOptions[i].IsCorrect = false
		}
		for _, correctIdx := range indices {
			if correctIdx < len(question.AnswerOptions) {
				question.AnswerOptions[correctIdx].IsCorrect = true
			}
		}

		log.Printf("[AnswersService] ✅ Установлены правильные ответы: %v для вопроса %d",
			indices, questionIdx+1)
	}

	return nil
}

// completeQuestionProcess завершает процесс создания/редактирования вопроса
func (s *AnswersService) completeQuestionProcess(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Проверяем режим: блок или простой чек-лист
	isBlockMode, _ := userState.Data["is_block_mode"].(bool)
	isEditBlockQuestion, _ := userState.Data["is_edit_block_questions"].(bool)

	// Очищаем временные данные
	s.cleanupQuestionData(userID)

	if isBlockMode || isEditBlockQuestion {
		// РЕЖИМ БЛОКА
		if isEditBlockQuestion {
			// Редактирование вопроса в блоке
			delete(userState.Data, "is_edit_block_questions")
			delete(userState.Data, "is_edit_mode")
			delete(userState.Data, "edit_question_position")
			delete(userState.Data, "selected_question_type")
			s.stateMgr.SetState(userID, userState)

			// Возвращаемся к списку вопросов блока
			s.stateMgr.NavigateTo(userID, "block-view-questions")
			s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
			log.Printf("[AnswersService] ✅ Редактирование вопроса в блоке завершено")
		} else {
			// СОЗДАНИЕ вопроса в блоке
			// НЕ удаляем is_block_mode - остаемся в режиме добавления
			delete(userState.Data, "selected_question_type")
			s.stateMgr.SetState(userID, userState)

			// Возвращаемся к выбору типа вопроса для добавления следующего
			s.stateMgr.NavigateTo(userID, "select-question-type")
			s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
			log.Printf("[AnswersService] ✅ Создание вопроса в блоке завершено. Возвращаемся в select-question-type")
		}
	} else {
		// РЕЖИМ ПРОСТОГО ЧЕК-ЛИСТА
		// Проверяем режим: создание или редактирование
		if isEdit, ok := userState.Data["is_edit_mode"].(bool); ok && isEdit {
			// Очищаем данные редактирования
			delete(userState.Data, "is_edit_mode")
			delete(userState.Data, "edit_question_position")
			delete(userState.Data, "selected_question_type")
			s.stateMgr.SetState(userID, userState)

			// Возвращаемся к списку вопросов после редактирования
			s.stateMgr.NavigateTo(userID, "view-question")
			s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
			log.Printf("[AnswersService] ✅ Редактирование вопроса завершено")
		} else {
			// Очищаем данные создания
			delete(userState.Data, "selected_question_type")
			s.stateMgr.SetState(userID, userState)

			// Возвращаемся к выбору типа вопроса для создания следующего
			s.stateMgr.NavigateTo(userID, "select-question-type")
			s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
			log.Printf("[AnswersService] ✅ Создание вопроса завершено")
		}
	}
}

// parseIndices парсит номера ответов
func (s *AnswersService) parseIndices(text string) ([]int, error) {
	parts := strings.Split(text, ",")
	indices := make([]int, 0)
	seen := make(map[int]bool)

	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}

		num, err := strconv.Atoi(part)
		if err != nil {
			return nil, fmt.Errorf("неверный номер: '%s'", part)
		}

		if num < 1 {
			return nil, fmt.Errorf("номер должен быть положительным")
		}

		idx := num - 1 // Конвертируем в 0-based

		if !seen[idx] {
			seen[idx] = true
			indices = append(indices, idx)
		}
	}

	if len(indices) == 0 {
		return nil, fmt.Errorf("укажите номера правильных ответов (например: 1 или 1,3)")
	}

	return indices, nil
}

// cleanupQuestionData очищает временные данные
func (s *AnswersService) cleanupQuestionData(userID int64) {
	userState, exists := s.stateMgr.GetState(userID)
	if !exists {
		return
	}

	delete(userState.Data, "last_question_index")
	delete(userState.Data, "answer_options_count")
	s.stateMgr.SetState(userID, userState)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\answers\service.go ===
package answers

import (
	"telegram-bot/internal/services/question"
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/manager"
)

type AnswersService struct {
	stateMgr    manager.StateManager
	screenSvc   *screen.ScreenService
	questionSvc *question.QuestionService
}

func NewAnswersService(stateMgr manager.StateManager, screenSvc *screen.ScreenService, questionSvc *question.QuestionService) *AnswersService {
	return &AnswersService{
		stateMgr:    stateMgr,
		screenSvc:   screenSvc,
		questionSvc: questionSvc,
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\auth\handlers.go ===
package auth

import (
	"fmt"
	"log"

	"telegram-bot/internal/state_manager/state"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

func (s *AuthService) HandleAuthorization(userID int64, update tgbotapi.Update, userState *state.UserState) error {
	dbUser, err := s.userSvc.AuthorizeAdmin(userID)
	if err != nil {
		return fmt.Errorf("❌ Ошибка авторизации: %s", err)
	}

	stateUser := convertToStateUser(dbUser)
	userState.SetUser(stateUser)
	s.stateMgr.SetState(userID, userState)
	s.stateMgr.NavigateTo(userID, "admin-menu")
	s.screenSvc.SendScreen(update.Message.Chat.ID, "admin-menu", userState)

	log.Printf("[AuthService] ✅ User %d авторизован как админ", userID)
	return nil
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\auth\helpers.go ===
package auth

import (
	"telegram-bot/internal/state_manager/types"
	"telegram-bot/internal/storage/models"
)

func convertToStateUser(dbUser *models.User) *types.User {
	if dbUser == nil {
		return nil
	}

	var role types.UserRole
	switch string(dbUser.Role) {
	case "admin":
		role = types.RoleAdmin
	case "user":
		role = types.RoleUser
	default:
		role = types.RoleUser
	}

	return &types.User{
		ID:         dbUser.ID,
		TelegramID: dbUser.TelegramID,
		Username:   dbUser.Username,
		FullName:   dbUser.FullName,
		Role:       role,
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\auth\service.go ===
package auth

import (
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/manager"
	"telegram-bot/internal/storage/service"
)

type AuthService struct {
	stateMgr  manager.StateManager
	userSvc   *service.UserService
	screenSvc *screen.ScreenService
}

func NewAuthService(stateMgr manager.StateManager, userSvc *service.UserService, screenSvc *screen.ScreenService) *AuthService {
	return &AuthService{
		stateMgr:  stateMgr,
		userSvc:   userSvc,
		screenSvc: screenSvc,
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\block_checklist\handlers.go ===
package block_checklist

import (
	"fmt"
	"log"
	"strings"

	"telegram-bot/internal/formatters"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"
	"telegram-bot/internal/storage/models"
	"telegram-bot/internal/utils"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// ========== СОЗДАНИЕ ЧЕК-ЛИСТА ==========

func (s *BlockChecklistService) HandleCancelCreateChecklist(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.stateMgr.NavigateTo(userID, "admin-menu")
	s.screenSvc.SendScreen(update.Message.Chat.ID, "admin-menu", userState)
}

func (s *BlockChecklistService) HandleCreateBlockChecklist(userID int64, update tgbotapi.Update, userState *state.UserState, text string) {
	checklist := types.NewDraftBlockedCheckList(text)
	userState.SetBlockedCheckList(checklist)
	s.stateMgr.SetState(userID, userState)
	s.stateMgr.NavigateTo(userID, "block-checklist-editor")
	s.screenSvc.SendScreen(update.Message.Chat.ID, "block-checklist-editor", userState)
}

// ========== РАБОТА С БЛОКАМИ ==========

// HandleAddBlock начинает процесс создания нового блока
func (s *BlockChecklistService) HandleAddBlock(userID int64, update tgbotapi.Update, userState *state.UserState) {
	delete(userState.Data, "current_block_index")
	s.stateMgr.SetState(userID, userState)

	s.stateMgr.NavigateTo(userID, "edit-block-name")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[BlockChecklistService] 🚀 Начало создания нового блока")
}

// HandleBlockNameInput обрабатывает ввод названия блока (и создание и редактирование)
func (s *BlockChecklistService) HandleBlockNameInput(userID int64, update tgbotapi.Update, userState *state.UserState, text string) {
	if len(strings.TrimSpace(text)) < 2 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Название блока должно содержать хотя бы 2 символа")
		return
	}

	checklistData, exists := s.stateMgr.GetCheckList(userID)
	if !exists {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	checklist, ok := checklistData.(*types.BlockedCheckList)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Неверный тип чек-листа")
		return
	}

	if blockIndex, exists := userState.Data["current_block_index"]; exists {
		idx, ok := blockIndex.(int)
		if !ok {
			s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка: неверный индекс блока")
			return
		}

		if idx < 0 || idx >= len(checklist.Blocks) {
			s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Блок не найден")
			return
		}

		oldName := checklist.Blocks[idx].Name
		checklist.Blocks[idx].Name = text

		s.stateMgr.NavigateTo(userID, "block-editor")
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

		log.Printf("[BlockChecklistService] ✅ Название блока изменено: '%s' → '%s' (индекс: %d)",
			oldName, text, idx)
	} else {
		block := types.NewBlock(text)
		checklist.AddBlock(block)

		blockIndex := len(checklist.Blocks) - 1
		userState.Data["current_block_index"] = blockIndex
		s.stateMgr.SetState(userID, userState)

		s.stateMgr.NavigateTo(userID, "block-editor")
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

		log.Printf("[BlockChecklistService] ✅ Создан блок '%s' (индекс: %d)", text, blockIndex)
	}
}

// HandleBlockSelection обрабатывает выбор блока из списка
func (s *BlockChecklistService) HandleBlockSelection(userID int64, update tgbotapi.Update, userState *state.UserState, buttonText string) {
	blockIndex, ok := utils.ExtractBlockIndexFromButton(buttonText)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Не удалось определить выбранный блок")
		return
	}

	checklistData, exists := s.stateMgr.GetCheckList(userID)
	if !exists {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	checklist, ok := checklistData.(*types.BlockedCheckList)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Неверный тип чек-листа")
		return
	}

	if blockIndex < 0 || blockIndex >= len(checklist.Blocks) {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Блок не найден")
		return
	}

	userState.Data["current_block_index"] = blockIndex
	s.stateMgr.SetState(userID, userState)

	s.stateMgr.NavigateTo(userID, "block-editor")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	blockName := checklist.Blocks[blockIndex].Name
	log.Printf("[BlockChecklistService] ✅ Выбран блок '%s' (индекс: %d)", blockName, blockIndex)
}

// HandleCancelBlockEdit отменяет создание/редактирование блока
func (s *BlockChecklistService) HandleCancelBlockEdit(userID int64, update tgbotapi.Update, userState *state.UserState) {
	delete(userState.Data, "current_block_index")
	s.stateMgr.SetState(userID, userState)

	s.stateMgr.NavigateTo(userID, "block-checklist-editor")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[BlockChecklistService] ❌ Отмена создания/редактирования блока")
}

// HandleBackFromBlockEditor возвращает из редактора блока к списку блоков
func (s *BlockChecklistService) HandleBackFromBlockEditor(userID int64, update tgbotapi.Update, userState *state.UserState) {
	delete(userState.Data, "current_block_index")
	s.stateMgr.SetState(userID, userState)

	s.stateMgr.NavigateTo(userID, "block-checklist-editor")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[BlockChecklistService] ◀️ Возврат к списку блоков")
}

// HandleAddQuestionToBlock начинает добавление вопроса в текущий блок
func (s *BlockChecklistService) HandleAddQuestionToBlock(userID int64, update tgbotapi.Update, userState *state.UserState) {
	userState.Data["is_block_mode"] = true
	s.stateMgr.SetState(userID, userState)

	s.stateMgr.NavigateTo(userID, "select-question-type")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[BlockChecklistService] ➕ Начало добавления вопроса в блок")
}

// HandleEditBlockName начинает редактирование названия текущего блока
func (s *BlockChecklistService) HandleEditBlockName(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.stateMgr.NavigateTo(userID, "edit-block-name")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[BlockChecklistService] ✏️ Начало редактирования названия блока")
}

// HandleBlockChecklistPreview показывает превью чек-листа с блоками
func (s *BlockChecklistService) HandleBlockChecklistPreview(userID int64, update tgbotapi.Update, userState *state.UserState) {
	checklistData, exists := s.stateMgr.GetCheckList(userID)
	if !exists {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	checklist, ok := checklistData.(*types.BlockedCheckList)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Неверный тип чек-листа")
		return
	}

	if len(checklist.Blocks) == 0 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист пустой. Добавьте блоки перед просмотром превью.")
		return
	}

	hasQuestions := false
	for _, block := range checklist.Blocks {
		if len(block.Questions) > 0 {
			hasQuestions = true
			break
		}
	}

	if !hasQuestions {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Все блоки пустые. Добавьте вопросы в блоки перед просмотром превью.")
		return
	}

	s.stateMgr.NavigateTo(userID, "checklist-preview")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[BlockChecklistService] 👁️ Показано превью чек-листа с блоками: %s", checklist.Name)
}

// HandleEditChecklistTitle начинает редактирование названия чек-листа с блоками
func (s *BlockChecklistService) HandleEditChecklistTitle(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.stateMgr.NavigateTo(userID, "edit-checklist-title")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleEditChecklistTitleInput обрабатывает ввод нового названия чек-листа с блоками
func (s *BlockChecklistService) HandleEditChecklistTitleInput(userID int64, update tgbotapi.Update, userState *state.UserState, newTitle string) {
	if len(strings.TrimSpace(newTitle)) == 0 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Название не может быть пустым")
		return
	}

	if len(newTitle) > 100 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Название слишком длинное (максимум 100 символов)")
		return
	}

	checklistData, exists := s.stateMgr.GetCheckList(userID)
	if !exists {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	checklist, ok := checklistData.(*types.BlockedCheckList)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Неверный тип чек-листа")
		return
	}

	oldName := checklist.Name
	checklist.Name = newTitle

	s.stateMgr.NavigateTo(userID, "block-checklist-editor")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[BlockChecklistService] ✅ Название чек-листа с блоками изменено: '%s' → '%s'", oldName, newTitle)
}

// HandleBackFromTitleEdit возвращает из редактирования названия
func (s *BlockChecklistService) HandleBackFromTitleEdit(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.stateMgr.NavigateTo(userID, "block-checklist-editor")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleBackFromPreview возвращает из превью
func (s *BlockChecklistService) HandleBackFromPreview(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.stateMgr.NavigateTo(userID, "block-checklist-editor")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleSaveDraft сохраняет черновик чек-листа с блоками
func (s *BlockChecklistService) HandleSaveDraft(userID int64, update tgbotapi.Update, userState *state.UserState) {
	checklistData, exists := s.stateMgr.GetCheckList(userID)
	if !exists {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	checklist, ok := checklistData.(*types.BlockedCheckList)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Неверный тип чек-листа для сохранения")
		return
	}

	if len(checklist.Blocks) == 0 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Нельзя сохранить чек-лист без блоков. Добавьте хотя бы один блок.")
		return
	}

	hasQuestions := false
	for _, block := range checklist.Blocks {
		if len(block.Questions) > 0 {
			hasQuestions = true
			break
		}
	}

	if !hasQuestions {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Нельзя сохранить чек-лист без вопросов. Добавьте вопросы в блоки.")
		return
	}

	var savedChecklist *models.Checklist
	var err error

	if checklist.ID > 0 {
		log.Printf("[BlockChecklistService] Редактирование чек-листа с блоками ID=%d", checklist.ID)
		savedChecklist, err = s.checklistSvc.UpdateChecklist(checklist.ID, checklist, userID)
		if err != nil {
			s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка обновления: "+err.Error())
			return
		}
		log.Printf("[BlockChecklistService] Старый чек-лист %d удален, создан новый ID=%d",
			checklist.ID, savedChecklist.ID)
	} else {
		log.Printf("[BlockChecklistService] Создание нового чек-листа с блоками")
		savedChecklist, err = s.checklistSvc.SaveBlockedChecklistDraft(checklist, userID)
		if err != nil {
			s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка сохранения: "+err.Error())
			return
		}
	}

	totalQuestions := 0
	for _, block := range checklist.Blocks {
		totalQuestions += len(block.Questions)
	}

	var message string
	if checklist.ID > 0 {
		message = fmt.Sprintf("✅ Чек-лист с блоками обновлен!\n\n📋 Название: %s\n🔄 Старый ID: %d → Новый ID: %d\n🧱 Блоков: %d\n📊 Вопросов: %d\n\nЧек-лист доступен в разделе 'Мои чек-листы'",
			savedChecklist.Name, checklist.ID, savedChecklist.ID, len(checklist.Blocks), totalQuestions)
	} else {
		message = fmt.Sprintf("✅ Черновик сохранен!\n\n📋 Название: %s\n🏷️ ID: %d\n🧱 Блоков: %d\n📊 Вопросов: %d\n\nЧек-лист доступен в разделе 'Мои чек-листы'",
			savedChecklist.Name, savedChecklist.ID, len(checklist.Blocks), totalQuestions)
	}

	s.screenSvc.SendMessage(update.Message.Chat.ID, message)

	s.stateMgr.ClearCheckList(userID)
	s.stateMgr.NavigateTo(userID, "admin-menu")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleSavePublish сохраняет и публикает чек-лист с блоками
func (s *BlockChecklistService) HandleSavePublish(userID int64, update tgbotapi.Update, userState *state.UserState) {
	checklistData, exists := s.stateMgr.GetCheckList(userID)
	if !exists {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	checklist, ok := checklistData.(*types.BlockedCheckList)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Неверный тип чек-листа для публикации")
		return
	}

	if len(checklist.Blocks) == 0 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Нельзя опубликовать чек-лист без блоков. Добавьте хотя бы один блок.")
		return
	}

	hasQuestions := false
	for _, block := range checklist.Blocks {
		if len(block.Questions) > 0 {
			hasQuestions = true
			break
		}
	}

	if !hasQuestions {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Нельзя опубликовать чек-лист без вопросов. Добавьте вопросы в блоки.")
		return
	}

	var savedChecklist *models.Checklist
	var err error

	if checklist.ID > 0 {
		log.Printf("[BlockChecklistService] Редактирование и публикация чек-листа с блоками ID=%d", checklist.ID)
		savedChecklist, err = s.checklistSvc.UpdateChecklist(checklist.ID, checklist, userID)
		if err != nil {
			s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка обновления: "+err.Error())
			return
		}
	} else {
		log.Printf("[BlockChecklistService] Создание и публикация нового чек-листа с блоками")
		savedChecklist, err = s.checklistSvc.SaveBlockedChecklistDraft(checklist, userID)
		if err != nil {
			s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка сохранения: "+err.Error())
			return
		}
	}

	// Подсчитываем общее количество вопросов ДО проверки ошибок
	totalQuestions := 0
	for _, block := range checklist.Blocks {
		totalQuestions += len(block.Questions)
	}

	// Публикуем чек-лист
	err = s.checklistSvc.PublishChecklist(savedChecklist.ID)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "⚠️ Чек-лист сохранен как черновик, но не опубликован: "+err.Error())

		var msg string
		if checklist.ID > 0 {
			msg = fmt.Sprintf("🔄 Чек-лист с блоками обновлен как черновик\n\n📋 Название: %s\n🔄 Старый ID: %d → Новый ID: %d\n🧱 Блоков: %d\n📊 Вопросов: %d\n\nНо не опубликован из-за ошибки",
				savedChecklist.Name, checklist.ID, savedChecklist.ID, len(checklist.Blocks), totalQuestions)
		} else {
			msg = fmt.Sprintf("✅ Черновик сохранен!\n\n📋 Название: %s\n🏷️ ID: %d\n🧱 Блоков: %d\n📊 Вопросов: %d\n\nНо не опубликован из-за ошибки",
				savedChecklist.Name, savedChecklist.ID, len(checklist.Blocks), totalQuestions)
		}
		s.screenSvc.SendMessage(update.Message.Chat.ID, msg)
	} else {
		var message string
		if checklist.ID > 0 {
			message = fmt.Sprintf("🚀 Чек-лист с блоками обновлен и опубликован!\n\n📋 Название: %s\n🔄 Старый ID: %d → Новый ID: %d\n🧱 Блоков: %d\n📊 Вопросов: %d\n\nТеперь чек-лист доступен для прохождения",
				savedChecklist.Name, checklist.ID, savedChecklist.ID, len(checklist.Blocks), totalQuestions)
		} else {
			message = fmt.Sprintf("🚀 Чек-лист с блоками опубликован!\n\n📋 Название: %s\n🏷️ ID: %d\n🧱 Блоков: %d\n📊 Вопросов: %d\n\nТеперь чек-лист доступен для прохождения",
				savedChecklist.Name, savedChecklist.ID, len(checklist.Blocks), totalQuestions)
		}
		s.screenSvc.SendMessage(update.Message.Chat.ID, message)
	}

	// Очищаем состояние и возвращаемся в главное меню
	s.stateMgr.ClearCheckList(userID)
	s.stateMgr.NavigateTo(userID, "admin-menu")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleConfirmExit начинает процесс подтверждения выхода в главное меню
func (s *BlockChecklistService) HandleConfirmExit(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.stateMgr.NavigateTo(userID, "confirm-exit-block-checklist")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleConfirmExitYes подтверждает выход в главное меню
func (s *BlockChecklistService) HandleConfirmExitYes(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.stateMgr.ClearCheckList(userID)
	s.stateMgr.NavigateTo(userID, "admin-menu")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	log.Printf("[BlockChecklistService] ✅ Выход из редактора блоков в главное меню")
}

// HandleConfirmExitNo отменяет выход в главное меню
func (s *BlockChecklistService) HandleConfirmExitNo(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.stateMgr.NavigateTo(userID, "block-checklist-editor")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	log.Printf("[BlockChecklistService] ❌ Отмена выхода из редактора блоков")
}

// HandleEditBlockQuestions начинает редактирование вопросов в блоке
func (s *BlockChecklistService) HandleEditBlockQuestions(userID int64, update tgbotapi.Update, userState *state.UserState) {
	checklistData, exists := s.stateMgr.GetCheckList(userID)
	if !exists {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	checklist, ok := checklistData.(*types.BlockedCheckList)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Неверный тип чек-листа")
		return
	}

	blockIdx, ok := userState.Data["current_block_index"].(int)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Блок не выбран")
		return
	}

	if blockIdx < 0 || blockIdx >= len(checklist.Blocks) {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Блок не найден")
		return
	}

	block := checklist.Blocks[blockIdx]

	if len(block.Questions) == 0 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ В блоке нет вопросов для редактирования")
		return
	}

	userState.Data["is_edit_block_questions"] = true
	userState.Data["edit_question_index"] = 0
	userState.Data["total_questions"] = len(block.Questions)
	s.stateMgr.SetState(userID, userState)

	s.stateMgr.NavigateTo(userID, "block-view-questions")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[BlockChecklistService] ✏️ Начало редактирования вопросов в блоке '%s'", block.Name)
}

// HandleBlockPreview показывает превью блока (без перехода на отдельный экран)
func (s *BlockChecklistService) HandleBlockPreview(userID int64, update tgbotapi.Update, userState *state.UserState) {
	checklistData, exists := s.stateMgr.GetCheckList(userID)
	if !exists {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	checklist, ok := checklistData.(*types.BlockedCheckList)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Неверный тип чек-листа")
		return
	}

	blockIdx, ok := userState.Data["current_block_index"].(int)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Блок не выбран")
		return
	}

	if blockIdx < 0 || blockIdx >= len(checklist.Blocks) {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Блок не найден")
		return
	}

	block := checklist.Blocks[blockIdx]

	if len(block.Questions) == 0 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Блок пустой. Добавьте вопросы перед просмотром превью.")
		return
	}

	message := formatters.FormatBlockPreview(block)

	s.screenSvc.SendMessage(update.Message.Chat.ID, message)

	log.Printf("[BlockChecklistService] 👁️ Показано превью блока '%s'", block.Name)
}

// HandleBackFromBlockQuestions возвращает из списка вопросов блока
func (s *BlockChecklistService) HandleBackFromBlockQuestions(userID int64, update tgbotapi.Update, userState *state.UserState) {
	delete(userState.Data, "is_edit_block_questions")
	s.stateMgr.SetState(userID, userState)

	s.stateMgr.NavigateTo(userID, "block-editor")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[BlockChecklistService] ◀️ Возврат из списка вопросов блока")
}

// HandleEditBlockQuestion начинает редактирование конкретного вопроса в блоке
func (s *BlockChecklistService) HandleEditBlockQuestion(userID int64, update tgbotapi.Update, userState *state.UserState, buttonText string) {
	questionNumber, err := utils.ExtractNumberFromPencilButton(buttonText)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Не удалось определить номер вопроса")
		return
	}

	checklistData, exists := s.stateMgr.GetCheckList(userID)
	if !exists {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	checklist, ok := checklistData.(*types.BlockedCheckList)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Неверный тип чек-листа")
		return
	}

	blockIdx, ok := userState.Data["current_block_index"].(int)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Блок не выбран")
		return
	}

	if blockIdx < 0 || blockIdx >= len(checklist.Blocks) {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Блок не найден")
		return
	}

	block := checklist.Blocks[blockIdx]

	if questionNumber < 1 || questionNumber > len(block.Questions) {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Вопрос с таким номером не существует")
		return
	}

	userState.Data["edit_question_index"] = questionNumber - 1
	userState.Data["is_edit_block_questions"] = true
	s.stateMgr.SetState(userID, userState)

	s.stateMgr.NavigateTo(userID, "edit-question-detail")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[BlockChecklistService] ✅ Выбран вопрос %d в блоке '%s' для редактирования",
		questionNumber, block.Name)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\block_checklist\service.go ===
package block_checklist

import (
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/manager"
	"telegram-bot/internal/storage/service"
)

type BlockChecklistService struct {
	stateMgr     manager.StateManager
	screenSvc    *screen.ScreenService
	checklistSvc *service.ChecklistService
}

func NewBlockChecklistService(
	stateMgr manager.StateManager,
	screenSvc *screen.ScreenService,
	checklistSvc *service.ChecklistService,
) *BlockChecklistService {
	return &BlockChecklistService{
		stateMgr:     stateMgr,
		screenSvc:    screenSvc,
		checklistSvc: checklistSvc,
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\menu\handlers.go ===
package menu

import (
	"fmt"
	"log"
	"telegram-bot/internal/state_manager/state"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// HandleCreateChecklist обрабатывает создание чек-листа
func (r *MenuService) HandleCreateSinpleChecklist(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Очищаем предыдущий чек-лист, если был
	r.stateMgr.ClearCheckList(userID)
	// Переходим к вводу названия
	r.stateMgr.NavigateTo(userID, "create-simple-checklist-name")
	r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleCreateChecklist обрабатывает создание чек-листа
func (r *MenuService) HandleCreateBlocksChecklist(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Очищаем предыдущий чек-лист, если был
	r.stateMgr.ClearCheckList(userID)
	// Переходим к вводу названия
	r.stateMgr.NavigateTo(userID, "create-block-checklist-name")
	r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleMyChecklists обрабатывает просмотр моих чек-листов
func (r *MenuService) HandleMyChecklists(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Получаем черновики пользователя
	drafts, err := r.checklistSvc.GetUserDrafts(userID)
	if err != nil {
		message := fmt.Sprintf("❌ Ошибка при получении чек-листов: %s", err.Error())
		r.screenSvc.SendMessage(update.Message.Chat.ID, message)
		return
	}

	if len(drafts) == 0 {
		r.screenSvc.SendMessage(update.Message.Chat.ID, "📭 У вас пока нет черновиков чек-листов.")
		return
	}

	// Сохраняем список чек-листов в состояние
	userState.Data["my_checklists"] = drafts
	r.stateMgr.SetState(userID, userState)

	// Переходим на экран списка чек-листов
	r.stateMgr.NavigateTo(userID, "my-checklists-list")
	r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[MenuService] ✅ Пользователь %d просмотрел список черновиков (%d шт.)", userID, len(drafts))
}

// HandleLogout обрабатывает выход из системы
func (r *MenuService) HandleLogout(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Логируем начало выхода
	userName := ""
	if userState != nil && userState.User != nil {
		userName = userState.User.FullName
	}
	log.Printf("[MenuRoutes] 🚪 User %d (%s) выходит из системы", userID, userName)

	// Очищаем состояние
	userState.SetUser(nil)
	r.stateMgr.DeleteState(userID)

	// Создаем новое состояние для авторизации
	newState := state.NewUserState(nil, "authorize-admin")
	r.stateMgr.SetState(userID, newState)

	// Отправляем экран авторизации
	r.screenSvc.SendScreen(update.Message.Chat.ID, "authorize-admin", newState)

	log.Printf("[MenuRoutes] ✅ User %d успешно вышел из системы", userID)
}

func (r *MenuService) HandlePublishedChecklists(userID int64, update tgbotapi.Update, userState *state.UserState) {
	r.publishedSvc.HandlePublishedChecklists(userID, update, userState)
}

func (r *MenuService) HandleCanceledChecklists(userID int64, update tgbotapi.Update, userState *state.UserState) {
	r.publishedSvc.HandleUnpublishedChecklists(userID, update, userState)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\menu\service.go ===
package menu

import (
	"telegram-bot/internal/services/published_checklists"
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/manager"
	"telegram-bot/internal/storage/service"
)

// MenuService содержит методы для маршрутизации главного меню
type MenuService struct {
	stateMgr     manager.StateManager
	screenSvc    *screen.ScreenService
	checklistSvc *service.ChecklistService // Добавляем ChecklistService
	publishedSvc *published_checklists.PublishedChecklistsService
}

// NewMenuService создает новый роутер для главного меню
func NewMenuService(
	stateMgr manager.StateManager,
	screenSvc *screen.ScreenService,
	checklistSvc *service.ChecklistService, // Добавляем параметр
	publishedSvc *published_checklists.PublishedChecklistsService,
) *MenuService {
	return &MenuService{
		stateMgr:     stateMgr,
		screenSvc:    screenSvc,
		checklistSvc: checklistSvc,
		publishedSvc: publishedSvc, // ИНИЦИАЛИЗИРУЙ
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\my_checklists\handlers.go ===
package my_checklists

import (
	"fmt"
	"log"

	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/storage/models"
	"telegram-bot/internal/utils"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// HandleChecklistNumber обрабатывает выбор чек-листа по номеру кнопки
func (s *MyChecklistsService) HandleChecklistNumber(userID int64, update tgbotapi.Update, userState *state.UserState, buttonText string) {
	// Извлекаем номер из кнопки (формат: "✏️ 1", "✏️ 2")
	number, err := utils.ExtractNumberFromPencilButton(buttonText)
	if err != nil || number < 1 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Не удалось определить выбранный чек-лист")
		return
	}

	// Получаем список чек-листов из состояния
	checklists, ok := userState.Data["my_checklists"].([]models.Checklist)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Список чек-листов не найден")
		return
	}

	// Проверяем диапазон
	if number > len(checklists) {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист с таким номером не существует")
		return
	}

	// Получаем выбранный чек-лист (0-based индекс)
	checklist := checklists[number-1]

	// Загружаем полные данные чек-листа
	dbChecklist, blocks, questions, answerOptions, err := s.checklistSvc.GetChecklistByID(checklist.ID)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка при загрузке чек-листа: "+err.Error())
		return
	}

	// ЗАГРУЖАЕМ ШАБЛОНЫ ДЛЯ ГРУППИРОВКИ ВОПРОСОВ ПО БЛОКАМ
	templates, err := s.checklistSvc.GetTemplatesByChecklistID(checklist.ID)
	if err != nil {
		log.Printf("[MyChecklistsService] ⚠️ Не удалось загрузить шаблоны для чек-листа %d: %v", checklist.ID, err)
		// Продолжаем без шаблонов
	}

	// Определяем тип чек-листа
	hasBlocks := len(blocks) > 0
	totalQuestions := len(questions)

	// Сохраняем данные в состояние
	userState.Data["current_checklist"] = dbChecklist
	userState.Data["has_blocks"] = hasBlocks
	userState.Data["total_questions"] = totalQuestions
	userState.Data["checklist_blocks"] = blocks
	userState.Data["checklist_questions"] = questions
	userState.Data["checklist_answer_options"] = answerOptions
	// Сохраняем шаблоны для группировки вопросов по блокам
	userState.Data["checklist_templates"] = templates

	s.stateMgr.SetState(userID, userState)

	// Переходим на экран деталей чек-листа (там будет превью + кнопки)
	s.stateMgr.NavigateTo(userID, "checklist-detail")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[MyChecklistsService] ✅ Загружен чек-лист ID=%d, тип=%v, вопросов=%d, шаблонов=%d",
		dbChecklist.ID, hasBlocks, totalQuestions, len(templates))
}

// HandleEditChecklist начинает редактирование чек-листа
func (s *MyChecklistsService) HandleEditChecklist(userID int64, update tgbotapi.Update, userState *state.UserState) {
	checklist, ok := userState.Data["current_checklist"].(*models.Checklist)
	if !ok || checklist == nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	hasBlocks, _ := userState.Data["has_blocks"].(bool)
	blocks, _ := userState.Data["checklist_blocks"].([]models.QuestionBlock)
	questions, _ := userState.Data["checklist_questions"].([]models.Question)
	answerOptions, _ := userState.Data["checklist_answer_options"].([]models.AnswerOption)

	if hasBlocks {
		// Редактирование чек-листа с блоками
		s.handleEditBlockChecklist(userID, update, userState, checklist, blocks, questions, answerOptions)
	} else {
		// Редактирование простого чек-листа
		s.handleEditSimpleChecklist(userID, update, userState, checklist, questions, answerOptions)
	}
}

// HandleDeleteChecklist начинает процесс удаления чек-листа
func (s *MyChecklistsService) HandleDeleteChecklist(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.stateMgr.NavigateTo(userID, "confirm-delete-checklist")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleConfirmDelete подтверждает удаление чек-листа
func (s *MyChecklistsService) HandleConfirmDelete(userID int64, update tgbotapi.Update, userState *state.UserState) {
	checklist, ok := userState.Data["current_checklist"].(*models.Checklist)
	if !ok || checklist == nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	// Удаляем из базы данных
	err := s.checklistSvc.DeleteChecklist(checklist.ID)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка при удалении: "+err.Error())
		return
	}

	log.Printf("[MyChecklistsService] Чек-лист %d удален", checklist.ID)

	// Форматируем дату создания
	createdAtStr := "(дата недоступна)"
	if !checklist.CreatedAt.IsZero() && checklist.CreatedAt.Year() > 1 {
		createdAtStr = checklist.CreatedAt.Format("02.01.2006")
	}

	// Отправляем сообщение об успехе
	message := fmt.Sprintf("✅ Чек-лист удален:\n\n📋 Название: %s\n🏷️ ID: %d\n📅 Создан: %s\n\nОбновляю список чек-листов...",
		checklist.Name, checklist.ID, createdAtStr)
	s.screenSvc.SendMessage(update.Message.Chat.ID, message)

	// Очищаем данные удаленного чек-листа
	delete(userState.Data, "current_checklist")
	delete(userState.Data, "has_blocks")
	delete(userState.Data, "total_questions")
	delete(userState.Data, "checklist_blocks")
	delete(userState.Data, "checklist_questions")
	delete(userState.Data, "checklist_answer_options")
	s.stateMgr.SetState(userID, userState)

	// Обновляем список чек-листов
	s.refreshChecklistsList(userID, update, userState)
}

// HandleCancelDelete отменяет удаление чек-листа
func (s *MyChecklistsService) HandleCancelDelete(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.stateMgr.NavigateTo(userID, "checklist-detail")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleBackFromDetail возвращает из деталей к списку
func (s *MyChecklistsService) HandleBackFromDetail(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Обновляем список чек-листов перед возвратом
	s.refreshChecklistsListOnBack(userID, update, userState)
}

// HandleBackFromList возвращает из списка в главное меню
func (s *MyChecklistsService) HandleBackFromList(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Очищаем список чек-листов
	delete(userState.Data, "my_checklists")
	s.stateMgr.SetState(userID, userState)

	s.stateMgr.NavigateTo(userID, "admin-menu")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandlePublishChecklist публикует чек-лист
func (s *MyChecklistsService) HandlePublishChecklist(userID int64, update tgbotapi.Update, userState *state.UserState) {
	checklist, ok := userState.Data["current_checklist"].(*models.Checklist)
	if !ok || checklist == nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	err := s.checklistSvc.PublishChecklist(checklist.ID)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка при публикации: "+err.Error())
		return
	}

	// Форматируем дату создания
	createdAtStr := "(дата недоступна)"
	if !checklist.CreatedAt.IsZero() && checklist.CreatedAt.Year() > 1 {
		createdAtStr = checklist.CreatedAt.Format("02.01.2006")
	}

	// Отправляем сообщение об успехе
	message := fmt.Sprintf("🚀 Чек-лист опубликован:\n\n📋 Название: %s\n🏷️ ID: %d\n📅 Создан: %s\n\nТеперь чек-лист доступен в разделе 'Опубликованные'",
		checklist.Name, checklist.ID, createdAtStr)
	s.screenSvc.SendMessage(update.Message.Chat.ID, message)

	// Обновляем список чек-листов
	s.refreshChecklistsList(userID, update, userState)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\my_checklists\helpers.go ===
package my_checklists

import (
	"log"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"
	"telegram-bot/internal/storage/models"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

func (s *MyChecklistsService) handleEditSimpleChecklist(userID int64, update tgbotapi.Update, userState *state.UserState,
	checklist *models.Checklist, questions []models.Question, answerOptions []models.AnswerOption) {

	// Создаем чек-лист в памяти из данных базы
	simpleChecklist := &types.SimpleCheckList{
		ID:        checklist.ID,
		Name:      checklist.Name,
		Status:    types.CheckListStatus(checklist.Status),
		Questions: make([]types.Question, 0),
	}

	// Группируем ответы по вопросам
	answersByQuestion := make(map[int64][]types.AnswerOption)
	for _, ao := range answerOptions {
		answersByQuestion[ao.QuestionID] = append(answersByQuestion[ao.QuestionID],
			types.NewAnswerOption(ao.Text, ao.IsCorrect))
	}

	// Добавляем вопросы
	for _, q := range questions {
		question := types.NewQuestion(q.Text, types.QuestionCategory(q.Category))
		if opts, ok := answersByQuestion[q.ID]; ok {
			question.AnswerOptions = opts
		}
		simpleChecklist.Questions = append(simpleChecklist.Questions, question)
	}

	// Устанавливаем чек-лист в состояние
	userState.SetSimpleCheckList(simpleChecklist)
	s.stateMgr.SetState(userID, userState)

	// Переходим в редактор
	s.stateMgr.NavigateTo(userID, "simple-checklist-editor")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[MyChecklistsService] ✅ Начато редактирование простого чек-листа ID=%d, вопросов=%d",
		checklist.ID, len(questions))
}

func (s *MyChecklistsService) handleEditBlockChecklist(userID int64, update tgbotapi.Update, userState *state.UserState,
	checklist *models.Checklist, blocks []models.QuestionBlock, questions []models.Question, answerOptions []models.AnswerOption) {

	// Создаем чек-лист с блоками в памяти
	blockedChecklist := &types.BlockedCheckList{
		ID:     checklist.ID,
		Name:   checklist.Name,
		Status: types.CheckListStatus(checklist.Status),
		Blocks: make([]types.Block, 0),
	}

	// Получаем шаблоны для группировки вопросов по блокам
	templates, err := s.checklistSvc.GetTemplatesByChecklistID(checklist.ID)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка при загрузке структуры чек-листа: "+err.Error())
		return
	}

	// Группируем вопросы по блокам
	questionsByBlock := make(map[int64][]models.Question)
	questionsMap := make(map[int64]models.Question)

	for _, q := range questions {
		questionsMap[q.ID] = q
	}

	for _, t := range templates {
		if t.BlockID != nil && questionsMap[t.QuestionID].ID != 0 {
			questionsByBlock[*t.BlockID] = append(questionsByBlock[*t.BlockID], questionsMap[t.QuestionID])
		}
	}

	// Группируем ответы по вопросам
	answersByQuestion := make(map[int64][]types.AnswerOption)
	for _, ao := range answerOptions {
		answersByQuestion[ao.QuestionID] = append(answersByQuestion[ao.QuestionID],
			types.NewAnswerOption(ao.Text, ao.IsCorrect))
	}

	// Создаем блоки
	for _, block := range blocks {
		typesBlock := types.NewBlock(block.Name)

		// Добавляем вопросы в блок
		if blockQuestions, ok := questionsByBlock[block.ID]; ok {
			for _, q := range blockQuestions {
				question := types.NewQuestion(q.Text, types.QuestionCategory(q.Category))
				if opts, ok := answersByQuestion[q.ID]; ok {
					question.AnswerOptions = opts
				}
				typesBlock.AddQuestion(question)
			}
		}

		blockedChecklist.AddBlock(typesBlock)
	}

	// Устанавливаем чек-лист в состояние
	userState.SetBlockedCheckList(blockedChecklist)
	s.stateMgr.SetState(userID, userState)

	// Переходим в редактор
	s.stateMgr.NavigateTo(userID, "block-checklist-editor")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[MyChecklistsService] ✅ Начато редактирование чек-листа с блоками ID=%d, блоков=%d",
		checklist.ID, len(blocks))
}

// refreshChecklistsList обновляет список чек-листов и показывает обновленную клавиатуру
func (s *MyChecklistsService) refreshChecklistsList(userID int64, update tgbotapi.Update, userState *state.UserState) {

	// Загружаем обновленный список черновиков
	drafts, err := s.checklistSvc.GetUserDrafts(userID)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "⚠️ Чек-лист удален, но не удалось обновить список: "+err.Error())
		// Все равно возвращаемся к списку
		s.stateMgr.NavigateTo(userID, "my-checklists-list")
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
		return
	}

	if len(drafts) == 0 {
		// Если черновиков не осталось
		s.screenSvc.SendMessage(update.Message.Chat.ID, "📭 У вас больше нет черновиков чек-листов.")

		// Очищаем список чек-листов из состояния
		delete(userState.Data, "my_checklists")
		s.stateMgr.SetState(userID, userState)

		// Возвращаемся в главное меню
		s.stateMgr.NavigateTo(userID, "admin-menu")
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
		return
	}

	// Сохраняем обновленный список в состояние
	userState.Data["my_checklists"] = drafts
	s.stateMgr.SetState(userID, userState)

	// Переходим на экран списка чек-листов
	s.stateMgr.NavigateTo(userID, "my-checklists-list")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[MyChecklistsService] ✅ Список чек-листов обновлен, осталось: %d", len(drafts))
}

// refreshChecklistsListOnBack обновляет список при возврате из деталей
func (s *MyChecklistsService) refreshChecklistsListOnBack(userID int64, update tgbotapi.Update, userState *state.UserState) {

	// Загружаем обновленный список черновиков
	drafts, err := s.checklistSvc.GetUserDrafts(userID)
	if err != nil {
		log.Printf("[MyChecklistsService] Ошибка при обновлении списка: %v", err)
		// Продолжаем с текущим списком
	} else {
		// Сохраняем обновленный список
		userState.Data["my_checklists"] = drafts
		s.stateMgr.SetState(userID, userState)
	}

	// Очищаем данные текущего чек-листа
	delete(userState.Data, "current_checklist")
	delete(userState.Data, "has_blocks")
	delete(userState.Data, "total_questions")
	delete(userState.Data, "checklist_blocks")
	delete(userState.Data, "checklist_questions")
	delete(userState.Data, "checklist_answer_options")

	s.stateMgr.SetState(userID, userState)
	s.stateMgr.NavigateTo(userID, "my-checklists-list")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\my_checklists\service.go ===
package my_checklists

import (
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/manager"
	"telegram-bot/internal/storage/service"
)

type MyChecklistsService struct {
	stateMgr     manager.StateManager
	screenSvc    *screen.ScreenService
	checklistSvc *service.ChecklistService
}

func NewMyChecklistsService(
	stateMgr manager.StateManager,
	screenSvc *screen.ScreenService,
	checklistSvc *service.ChecklistService,
) *MyChecklistsService {
	return &MyChecklistsService{
		stateMgr:     stateMgr,
		screenSvc:    screenSvc,
		checklistSvc: checklistSvc,
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\published_checklists\handlers.go ===
package published_checklists

import (
	"fmt"
	"log"

	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/storage/models"
	"telegram-bot/internal/utils"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// HandlePublishedChecklists показывает опубликованные чек-листы
func (s *PublishedChecklistsService) HandlePublishedChecklists(userID int64, update tgbotapi.Update, userState *state.UserState) {
	checklists, err := s.checklistSvc.GetUserPublished(userID)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка при получении опубликованных чек-листов: "+err.Error())
		return
	}

	if len(checklists) == 0 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "🚀 У вас пока нет опубликованных чек-листов.")
		return
	}

	// Сохраняем список и тип (published)
	userState.Data["published_checklists"] = checklists
	userState.Data["checklists_type"] = "published" // тип списка: published/unpublished
	s.stateMgr.SetState(userID, userState)

	// Переходим на экран списка
	s.stateMgr.NavigateTo(userID, "published-checklists-list")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[PublishedChecklistsService] ✅ Пользователь %d просмотрел опубликованные чек-листы (%d шт.)", userID, len(checklists))
}

// HandleUnpublishedChecklists показывает отмененные чек-листы
func (s *PublishedChecklistsService) HandleUnpublishedChecklists(userID int64, update tgbotapi.Update, userState *state.UserState) {
	checklists, err := s.checklistSvc.GetUserUnpublished(userID)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка при получении отмененных чек-листов: "+err.Error())
		return
	}

	if len(checklists) == 0 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "🚫 У вас пока нет отмененных публикаций.")
		return
	}

	// Сохраняем список и тип (unpublished)
	userState.Data["published_checklists"] = checklists
	userState.Data["checklists_type"] = "unpublished"
	s.stateMgr.SetState(userID, userState)

	// Переходим на экран списка
	s.stateMgr.NavigateTo(userID, "published-checklists-list")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[PublishedChecklistsService] ✅ Пользователь %d просмотрел отмененные чек-листы (%d шт.)", userID, len(checklists))
}

// HandleChecklistNumber обрабатывает выбор чек-листа по номеру
func (s *PublishedChecklistsService) HandleChecklistNumber(userID int64, update tgbotapi.Update, userState *state.UserState, buttonText string) {
	// Извлекаем номер из кнопки (формат: "✏️ 1", "✏️ 2")
	number, err := utils.ExtractNumberFromPencilButton(buttonText)
	if err != nil || number < 1 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Не удалось определить выбранный чек-лист")
		return
	}

	// Получаем список чек-листов из состояния
	checklists, ok := userState.Data["published_checklists"].([]models.Checklist)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Список чек-листов не найден")
		return
	}

	// Проверяем диапазон
	if number > len(checklists) {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист с таким номером не существует")
		return
	}

	// Получаем выбранный чек-лист
	checklist := checklists[number-1]
	checklistType, _ := userState.Data["checklists_type"].(string)

	// Загружаем полные данные чек-листа
	dbChecklist, blocks, questions, answerOptions, err := s.checklistSvc.GetChecklistByID(checklist.ID)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка при загрузке чек-листа: "+err.Error())
		return
	}

	// ДОБАВЛЕНО: Загружаем шаблоны для группировки вопросов по блокам
	templates, err := s.checklistSvc.GetTemplatesByChecklistID(checklist.ID)
	if err != nil {
		log.Printf("[PublishedChecklistsService] ⚠️ Не удалось загрузить шаблоны для чек-листа %d: %v", checklist.ID, err)
		// Продолжаем без шаблонов
	}

	// Определяем тип чек-листа
	hasBlocks := len(blocks) > 0
	totalQuestions := len(questions)

	// Сохраняем данные в состояние
	userState.Data["current_published_checklist"] = dbChecklist
	userState.Data["published_has_blocks"] = hasBlocks
	userState.Data["published_total_questions"] = totalQuestions
	userState.Data["published_checklist_blocks"] = blocks
	userState.Data["published_checklist_questions"] = questions
	userState.Data["published_checklist_answer_options"] = answerOptions
	// ДОБАВЛЕНО: Сохраняем шаблоны
	userState.Data["published_checklist_templates"] = templates
	userState.Data["current_checklist_type"] = checklistType

	s.stateMgr.SetState(userID, userState)

	// Переходим на экран деталей
	s.stateMgr.NavigateTo(userID, "published-checklist-detail")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[PublishedChecklistsService] ✅ Загружен чек-лист ID=%d, тип=%s, вопросов=%d, шаблонов=%d",
		dbChecklist.ID, checklistType, totalQuestions, len(templates))
}

// HandleUnpublish снимает чек-лист с публикации
func (s *PublishedChecklistsService) HandleUnpublish(userID int64, update tgbotapi.Update, userState *state.UserState) {
	checklist, ok := userState.Data["current_published_checklist"].(*models.Checklist)
	if !ok || checklist == nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	err := s.checklistSvc.UnpublishChecklist(checklist.ID)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка при снятии с публикации: "+err.Error())
		return
	}

	// Отправляем сообщение об успехе
	message := fmt.Sprintf("🚫 Чек-лист снят с публикации:\n\n📋 Название: %s\n🏷️ ID: %d\n\nТеперь он доступен в разделе 'Отмененные публикации'",
		checklist.Name, checklist.ID)
	s.screenSvc.SendMessage(update.Message.Chat.ID, message)

	// Возвращаемся в главное меню
	s.cleanupPublishedChecklistData(userState)
	s.stateMgr.NavigateTo(userID, "admin-menu")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[PublishedChecklistsService] ✅ Чек-лист %d снят с публикации", checklist.ID)
}

// HandleRepublish возвращает чек-лист в публикацию
func (s *PublishedChecklistsService) HandleRepublish(userID int64, update tgbotapi.Update, userState *state.UserState) {
	checklist, ok := userState.Data["current_published_checklist"].(*models.Checklist)
	if !ok || checklist == nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	err := s.checklistSvc.RepublishChecklist(checklist.ID)
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка при возврате в публикацию: "+err.Error())
		return
	}

	// Отправляем сообщение об успехе
	message := fmt.Sprintf("🚀 Чек-лист возвращен в публикацию:\n\n📋 Название: %s\n🏷️ ID: %d\n\nТеперь он доступен в разделе 'Опубликованные'",
		checklist.Name, checklist.ID)
	s.screenSvc.SendMessage(update.Message.Chat.ID, message)

	// Возвращаемся в главное меню
	s.cleanupPublishedChecklistData(userState)
	s.stateMgr.NavigateTo(userID, "admin-menu")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[PublishedChecklistsService] ✅ Чек-лист %d возвращен в публикацию", checklist.ID)
}

// HandleBackFromDetail возвращает из деталей к списку
func (s *PublishedChecklistsService) HandleBackFromDetail(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.cleanupPublishedChecklistData(userState)
	s.stateMgr.NavigateTo(userID, "published-checklists-list")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleBackFromList возвращает из списка в главное меню
func (s *PublishedChecklistsService) HandleBackFromList(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Очищаем данные
	delete(userState.Data, "published_checklists")
	delete(userState.Data, "checklists_type")
	s.stateMgr.SetState(userID, userState)

	s.stateMgr.NavigateTo(userID, "admin-menu")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\published_checklists\helpers.go ===
package published_checklists

import (
	"telegram-bot/internal/state_manager/state"
)

// cleanupPublishedChecklistData очищает данные опубликованного чек-листа
func (s *PublishedChecklistsService) cleanupPublishedChecklistData(userState *state.UserState) {
	delete(userState.Data, "current_published_checklist")
	delete(userState.Data, "current_checklist_type")
	delete(userState.Data, "published_has_blocks")
	delete(userState.Data, "published_total_questions")
	delete(userState.Data, "published_checklist_blocks")
	delete(userState.Data, "published_checklist_questions")
	delete(userState.Data, "published_checklist_answer_options")
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\published_checklists\service.go ===
package published_checklists

import (
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/manager"
	"telegram-bot/internal/storage/service"
)

type PublishedChecklistsService struct {
	stateMgr     manager.StateManager
	screenSvc    *screen.ScreenService
	checklistSvc *service.ChecklistService
}

func NewPublishedChecklistsService(
	stateMgr manager.StateManager,
	screenSvc *screen.ScreenService,
	checklistSvc *service.ChecklistService,
) *PublishedChecklistsService {
	return &PublishedChecklistsService{
		stateMgr:     stateMgr,
		screenSvc:    screenSvc,
		checklistSvc: checklistSvc,
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\question\handlers.go ===
package question

import (
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// HandleBack обрабатывает кнопку "Назад" для вопросов
func (s *QuestionService) HandleBack(userID int64, update tgbotapi.Update, userState *state.UserState) {
	currentScreen := userState.GetCurrentScreen()

	switch currentScreen {
	case "select-question-type":
		// Определяем куда возвращаться в зависимости от режима
		isBlockMode, _ := userState.Data["is_block_mode"].(bool)
		if isBlockMode {
			// Возвращаемся в редактор блока
			delete(userState.Data, "is_block_mode")
			s.stateMgr.SetState(userID, userState)
			s.stateMgr.NavigateTo(userID, "block-editor")
		} else if isEdit, ok := userState.Data["is_edit_mode"].(bool); ok && isEdit {
			// Редактирование вопроса в простом чек-листе
			delete(userState.Data, "is_edit_mode")
			delete(userState.Data, "edit_question_position")
			s.stateMgr.SetState(userID, userState)
			s.stateMgr.NavigateTo(userID, "edit-question-detail")
		} else {
			// Создание вопроса в простом чек-листе
			s.stateMgr.NavigateTo(userID, "simple-checklist-editor")
		}
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	case "enter-question-text":
		// Возвращаемся к выбору типа вопроса
		s.stateMgr.NavigateTo(userID, "select-question-type")
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	default:
		s.stateMgr.NavigateTo(userID, "simple-checklist-editor")
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	}
}

// HandleCompliance обрабатывает выбор типа "Соответствие"
func (s *QuestionService) HandleCompliance(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.handleQuestionType(userID, update, userState, types.CategoryCompliance)
}

// HandleSingleChoice обрабатывает выбор типа "Одиночный выбор"
func (s *QuestionService) HandleSingleChoice(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.handleQuestionType(userID, update, userState, types.CategorySingleChoice)
}

// HandleMultipleChoice обрабатывает выбор типа "Множественный выбор"
func (s *QuestionService) HandleMultipleChoice(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.handleQuestionType(userID, update, userState, types.CategoryMultipleChoice)
}

// HandleTextAnswer обрабатывает выбор типа "Текстовый ответ"
func (s *QuestionService) HandleTextAnswer(userID int64, update tgbotapi.Update, userState *state.UserState) {
	s.handleQuestionType(userID, update, userState, types.CategoryTextAnswer)
}

// HandleQuestionTextInput обрабатывает ввод текста вопроса
func (s *QuestionService) HandleQuestionTextInput(userID int64, update tgbotapi.Update, userState *state.UserState, text string) {
	categoryStr, ok := userState.Data["selected_question_type"].(string)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Тип вопроса не найден")
		s.stateMgr.NavigateTo(userID, "select-question-type")
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
		return
	}

	err := s.createQuestion(userID, text, types.QuestionCategory(categoryStr))
	if err != nil {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ "+err.Error())
		return
	}

	category := types.QuestionCategory(categoryStr)

	// Только для SingleChoice и MultipleChoice нужны варианты ответов
	if category == types.CategorySingleChoice || category == types.CategoryMultipleChoice {
		s.stateMgr.NavigateTo(userID, "enter-answer-options")
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	} else {
		// Для Compliance и TextAnswer - завершаем процесс
		s.completeQuestionCreation(userID, update, userState)
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\question\helpers.go ===
package question

import (
	"fmt"
	"log"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// handleQuestionType общая логика выбора типа
func (s *QuestionService) handleQuestionType(userID int64, update tgbotapi.Update, userState *state.UserState, category types.QuestionCategory) {
	// Всегда перезаписываем тип
	userState.Data["selected_question_type"] = string(category)
	s.stateMgr.SetState(userID, userState)
	s.stateMgr.NavigateTo(userID, "enter-question-text")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// createQuestion создает или заменяет вопрос
func (s *QuestionService) createQuestion(userID int64, text string, category types.QuestionCategory) error {
	userState, exists := s.stateMgr.GetState(userID)
	if !exists {
		return fmt.Errorf("состояние не найдено")
	}

	// Проверяем режим: блок или простой чек-лист
	isBlockMode, _ := userState.Data["is_block_mode"].(bool)
	isEditBlockQuestion, _ := userState.Data["is_edit_block_questions"].(bool)

	if isBlockMode || isEditBlockQuestion {
		// РЕЖИМ БЛОКА: добавляем вопрос в текущий блок
		return s.createQuestionInBlock(userID, text, category, userState, isEditBlockQuestion)
	} else {
		// РЕЖИМ ПРОСТОГО ЧЕК-ЛИСТА: существующая логика
		return s.createQuestionInSimpleChecklist(userID, text, category, userState)
	}
}

// createQuestionInBlock добавляет вопрос в текущий блок
func (s *QuestionService) createQuestionInBlock(userID int64, text string, category types.QuestionCategory, userState *state.UserState, isEditMode bool) error {
	checklistData, exists := s.stateMgr.GetCheckList(userID)
	if !exists {
		return fmt.Errorf("чек-лист не найден")
	}

	checklist, ok := checklistData.(*types.BlockedCheckList)
	if !ok {
		return fmt.Errorf("неверный тип чек-листа для режима блока")
	}

	// Получаем индекс текущего блока
	blockIndex, ok := userState.Data["current_block_index"].(int)
	if !ok {
		return fmt.Errorf("блок не выбран")
	}

	if blockIndex < 0 || blockIndex >= len(checklist.Blocks) {
		return fmt.Errorf("неверный индекс блока")
	}

	// Проверяем, редактируем ли существующий вопрос в блоке
	if isEditMode {
		// РЕДАКТИРОВАНИЕ вопроса в блоке
		if position, ok := userState.Data["edit_question_position"].(int); ok {
			if position >= 0 && position < len(checklist.Blocks[blockIndex].Questions) {
				// Создаем новый вопрос
				question := types.NewQuestion(text, category)

				// Заменяем вопрос на позиции
				checklist.Blocks[blockIndex].Questions[position] = question

				// Сохраняем индекс последнего созданного вопроса для работы с ответами
				userState.Data["last_question_index"] = position
				s.stateMgr.SetState(userID, userState)

				log.Printf("[QuestionService] ✅ Вопрос %d в блоке %d заменен: '%s' (%s)",
					position+1, blockIndex+1, text, category)
				return nil
			}
		}
	}

	// СОЗДАНИЕ нового вопроса в блоке
	question := types.NewQuestion(text, category)

	// Добавляем вопрос в блок
	checklist.Blocks[blockIndex].AddQuestion(question)

	// Сохраняем индекс последнего созданного вопроса
	lastQuestionIndex := len(checklist.Blocks[blockIndex].Questions) - 1
	userState.Data["last_question_index"] = lastQuestionIndex
	s.stateMgr.SetState(userID, userState)

	log.Printf("[QuestionService] ✅ Вопрос добавлен в блок %d: '%s' (%s)",
		blockIndex+1, text, category)
	return nil
}

// createQuestionInSimpleChecklist добавляет вопрос в простой чек-лист
func (s *QuestionService) createQuestionInSimpleChecklist(userID int64, text string, category types.QuestionCategory, userState *state.UserState) error {
	checklistData, exists := s.stateMgr.GetCheckList(userID)
	if !exists {
		return fmt.Errorf("чек-лист не найден")
	}

	simpleChecklist, ok := checklistData.(*types.SimpleCheckList)
	if !ok {
		return fmt.Errorf("неверный тип чек-листа")
	}

	// Проверяем, редактируем ли существующий вопрос
	if isEdit, ok := userState.Data["is_edit_mode"].(bool); ok && isEdit {
		// РЕДАКТИРОВАНИЕ: Заменяем вопрос на заданной позиции
		if position, ok := userState.Data["edit_question_position"].(int); ok {
			if position >= 0 && position < len(simpleChecklist.Questions) {
				// Создаем новый вопрос
				question := types.NewQuestion(text, category)

				// Заменяем вопрос на позиции
				simpleChecklist.Questions[position] = question

				// Сохраняем индекс последнего созданного вопроса для работы с ответами
				userState.Data["last_question_index"] = position
				s.stateMgr.SetState(userID, userState)

				log.Printf("[QuestionService] ✅ Вопрос %d заменен: '%s' (%s)", position+1, text, category)
				return nil
			}
		}
	}

	// СОЗДАНИЕ: Добавляем новый вопрос в конец
	question := types.NewQuestion(text, category)
	simpleChecklist.AddQuestion(question)
	userState.Data["last_question_index"] = len(simpleChecklist.Questions) - 1
	s.stateMgr.SetState(userID, userState)

	log.Printf("[QuestionService] ✅ Вопрос создан: '%s' (%s)", text, category)
	return nil
}

// completeQuestionCreation завершает процесс создания/редактирования вопроса
func (s *QuestionService) completeQuestionCreation(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Проверяем режим: блок или простой чек-лист
	isBlockMode, _ := userState.Data["is_block_mode"].(bool)
	isEditBlockQuestion, _ := userState.Data["is_edit_block_questions"].(bool)

	if isBlockMode || isEditBlockQuestion {
		// РЕЖИМ БЛОКА (создание или редактирование вопроса)
		if isEditBlockQuestion {
			// Редактирование вопроса в блоке
			delete(userState.Data, "is_edit_block_questions")
			delete(userState.Data, "is_edit_mode")
			delete(userState.Data, "edit_question_position")
			delete(userState.Data, "selected_question_type")
			s.stateMgr.SetState(userID, userState)

			// Возвращаемся к списку вопросов блока
			s.stateMgr.NavigateTo(userID, "block-view-questions")
			s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
			log.Printf("[QuestionService] ✅ Редактирование вопроса в блоке завершено")
		} else {
			// СОЗДАНИЕ вопроса в блоке
			// НЕ удаляем is_block_mode - остаемся в режиме добавления
			delete(userState.Data, "selected_question_type")
			s.stateMgr.SetState(userID, userState)

			// Возвращаемся к выбору типа вопроса для добавления следующего
			s.stateMgr.NavigateTo(userID, "select-question-type")
			s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
			log.Printf("[QuestionService] ✅ Создание вопроса в блоке завершено. Возвращаемся в select-question-type")
		}
	} else {
		// РЕЖИМ ПРОСТОГО ЧЕК-ЛИСТА
		// Проверяем режим: создание или редактирование
		if isEdit, ok := userState.Data["is_edit_mode"].(bool); ok && isEdit {
			// Очищаем данные редактирования
			delete(userState.Data, "is_edit_mode")
			delete(userState.Data, "edit_question_position")
			delete(userState.Data, "selected_question_type")
			s.stateMgr.SetState(userID, userState)

			// Возвращаемся к списку вопросов после редактирования
			s.stateMgr.NavigateTo(userID, "view-question")
			s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
			log.Printf("[QuestionService] ✅ Редактирование вопроса завершено")
		} else {
			// Очищаем данные создания
			delete(userState.Data, "selected_question_type")
			s.stateMgr.SetState(userID, userState)

			// Возвращаемся к выбору типа вопроса для создания следующего
			s.stateMgr.NavigateTo(userID, "select-question-type")
			s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
			log.Printf("[QuestionService] ✅ Создание вопроса завершено")
		}
	}
}

// GetLastQuestionIndex возвращает индекс последнего вопроса
func (s *QuestionService) GetLastQuestionIndex(userID int64) (int, error) {
	userState, exists := s.stateMgr.GetState(userID)
	if !exists {
		return -1, fmt.Errorf("состояние не найдено")
	}

	idx, ok := userState.Data["last_question_index"].(int)
	if !ok {
		return -1, fmt.Errorf("индекс вопроса не найден")
	}

	return idx, nil
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\question\service.go ===
package question

import (
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/manager"
)

type QuestionService struct {
	stateMgr  manager.StateManager
	screenSvc *screen.ScreenService
}

func NewQuestionService(stateMgr manager.StateManager, screenSvc *screen.ScreenService) *QuestionService {
	return &QuestionService{
		stateMgr:  stateMgr,
		screenSvc: screenSvc,
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\question_edit\handlers.go ===
package question_edit

import (
	"log"
	"strconv"
	"strings"

	"telegram-bot/internal/buttons"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// HandleEditQuestions начинает редактирование вопросов (показывает список)
func (s *QuestionEditService) HandleEditQuestions(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Проверяем, редактируем ли вопросы в блоке
	isBlockQuestion, _ := userState.Data["is_edit_block_questions"].(bool)

	if isBlockQuestion {
		// Редактирование вопросов в блоке
		checklistData, _ := s.stateMgr.GetCheckList(userID)
		blockedChecklist := checklistData.(*types.BlockedCheckList)
		blockIdx, _ := userState.Data["current_block_index"].(int)

		// Сохраняем индекс редактируемого вопроса (первый по умолчанию)
		userState.Data["edit_question_index"] = 0
		userState.Data["total_questions"] = len(blockedChecklist.Blocks[blockIdx].Questions)
		s.stateMgr.SetState(userID, userState)

		// Переходим к просмотру списка вопросов блока
		s.stateMgr.NavigateTo(userID, "block-view-questions")
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	} else {
		// Редактирование вопросов в простом чек-листе (существующая логика)
		checklistData, _ := s.stateMgr.GetCheckList(userID)
		simpleChecklist := checklistData.(*types.SimpleCheckList)

		// Сохраняем индекс редактируемого вопроса (первый по умолчанию)
		userState.Data["edit_question_index"] = 0
		userState.Data["total_questions"] = len(simpleChecklist.Questions)
		s.stateMgr.SetState(userID, userState)

		// Переходим к просмотру списка вопросов
		s.stateMgr.NavigateTo(userID, "view-question")
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
	}
}

// HandleBack обрабатывает кнопку "Назад" при редактировании вопросов
func (s *QuestionEditService) HandleBack(userID int64, update tgbotapi.Update, userState *state.UserState) {
	currentScreen := userState.GetCurrentScreen()

	switch currentScreen {
	case "view-question":
		// Возвращаемся в редактор простого чек-листа
		s.stateMgr.NavigateTo(userID, "simple-checklist-editor")
	case "block-view-questions":
		// Возвращаемся в редактор блока
		delete(userState.Data, "is_edit_block_questions")
		s.stateMgr.SetState(userID, userState)
		s.stateMgr.NavigateTo(userID, "block-editor")
	case "edit-question-detail":
		// Возвращаемся к списку вопросов
		isBlockQuestion, _ := userState.Data["is_edit_block_questions"].(bool)
		if isBlockQuestion {
			s.stateMgr.NavigateTo(userID, "block-view-questions")
		} else {
			s.stateMgr.NavigateTo(userID, "view-question")
		}
	case "edit-question-text", "edit-question-type", "confirm-delete-question":
		// Возвращаемся к деталям вопроса
		s.stateMgr.NavigateTo(userID, "edit-question-detail")
	default:
		s.stateMgr.NavigateTo(userID, "simple-checklist-editor")
	}

	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleQuestionNumber обрабатывает выбор номера вопроса
func (s *QuestionEditService) HandleQuestionNumber(userID int64, update tgbotapi.Update, userState *state.UserState, text string) {
	// Извлекаем номер из кнопки с карандашом
	cleanText := strings.TrimPrefix(text, "✏️")
	cleanText = strings.TrimSpace(cleanText)

	number, err := strconv.Atoi(cleanText)
	if err != nil || number < 1 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Неверный номер вопроса")
		return
	}

	// Проверяем, редактируем ли вопросы в блоке
	isBlockQuestion, _ := userState.Data["is_edit_block_questions"].(bool)

	if isBlockQuestion {
		// Редактирование вопроса в блоке
		checklistData, _ := s.stateMgr.GetCheckList(userID)
		blockedChecklist := checklistData.(*types.BlockedCheckList)
		blockIdx, _ := userState.Data["current_block_index"].(int)

		if number > len(blockedChecklist.Blocks[blockIdx].Questions) {
			s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Вопрос с таким номером не существует")
			return
		}
	} else {
		// Редактирование вопроса в простом чек-листе
		checklistData, _ := s.stateMgr.GetCheckList(userID)
		simpleChecklist := checklistData.(*types.SimpleCheckList)

		if number > len(simpleChecklist.Questions) {
			s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Вопрос с таким номером не существует")
			return
		}
	}

	// Сохраняем индекс выбранного вопроса
	userState.Data["edit_question_index"] = number - 1
	s.stateMgr.SetState(userID, userState)

	// Переходим на экран редактирования конкретного вопроса
	s.stateMgr.NavigateTo(userID, "edit-question-detail")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[QuestionEditService] ✅ Выбран вопрос %d для редактирования", number)
}

// HandleEditQuestionText начинает редактирование текста вопроса
func (s *QuestionEditService) HandleEditQuestionText(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Переходим к редактированию текста
	s.stateMgr.NavigateTo(userID, "edit-question-text")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleEditQuestionType начинает процесс изменения типа вопроса
func (s *QuestionEditService) HandleEditQuestionType(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Получаем индекс редактируемого вопроса
	idx, ok := userState.Data["edit_question_index"].(int)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка: не найден индекс вопроса")
		return
	}

	// Сохраняем индекс и позицию вопроса для редактирования
	userState.Data["edit_question_position"] = idx
	userState.Data["is_edit_mode"] = true
	s.stateMgr.SetState(userID, userState)

	// Переходим к выбору типа вопроса (полный флоу создания с нуля)
	s.stateMgr.NavigateTo(userID, "select-question-type")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[QuestionEditService] 🚀 Начинаем изменение типа вопроса %d", idx+1)
}

// HandleDeleteQuestion начинает процесс удаления вопроса
func (s *QuestionEditService) HandleDeleteQuestion(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Переходим к подтверждению удаления
	s.stateMgr.NavigateTo(userID, "confirm-delete-question")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleNewQuestionTextInput обрабатывает ввод нового текста вопроса
func (s *QuestionEditService) HandleNewQuestionTextInput(userID int64, update tgbotapi.Update, userState *state.UserState, newText string) {
	// Проверяем минимальную длину
	if len(strings.TrimSpace(newText)) < 3 {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Текст вопроса должен содержать хотя бы 3 символа")
		return
	}

	// Получаем индекс вопроса
	idx, ok := userState.Data["edit_question_index"].(int)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка: не найден индекс вопроса")
		return
	}

	// Проверяем, редактируем ли вопрос в блоке
	isBlockQuestion, _ := userState.Data["is_edit_block_questions"].(bool)

	if isBlockQuestion {
		// Редактирование вопроса в блоке
		checklistData, _ := s.stateMgr.GetCheckList(userID)
		checklist := checklistData.(*types.BlockedCheckList)
		blockIdx, _ := userState.Data["current_block_index"].(int)

		// Проверяем диапазон
		if idx < 0 || idx >= len(checklist.Blocks[blockIdx].Questions) {
			s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка: неверный индекс вопроса")
			return
		}

		// Обновляем текст вопроса
		checklist.Blocks[blockIdx].Questions[idx].Text = newText

		// Возвращаемся к деталям вопроса
		s.stateMgr.NavigateTo(userID, "edit-question-detail")
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

		log.Printf("[QuestionEditService] ✅ Текст вопроса %d в блоке изменен", idx+1)
	} else {
		// Редактирование вопроса в простом чек-листе
		checklistData, _ := s.stateMgr.GetCheckList(userID)
		simpleChecklist := checklistData.(*types.SimpleCheckList)

		// Проверяем диапазон
		if idx < 0 || idx >= len(simpleChecklist.Questions) {
			s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка: неверный индекс вопроса")
			return
		}

		// Обновляем текст вопроса
		simpleChecklist.Questions[idx].Text = newText

		// Возвращаемся к деталям вопроса
		s.stateMgr.NavigateTo(userID, "edit-question-detail")
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

		log.Printf("[QuestionEditService] ✅ Текст вопроса %d изменен", idx+1)
	}
}

// HandleQuestionTypeSelection обрабатывает выбор типа вопроса (для создания/редактирования)
func (s *QuestionEditService) HandleQuestionTypeSelection(userID int64, update tgbotapi.Update, userState *state.UserState, text string) {
	var category types.QuestionCategory

	switch text {
	case buttons.BtnCompliance:
		category = types.CategoryCompliance
	case buttons.BtnSingleChoice:
		category = types.CategorySingleChoice
	case buttons.BtnMultipleChoice:
		category = types.CategoryMultipleChoice
	case buttons.BtnTextAnswer:
		category = types.CategoryTextAnswer
	case buttons.BtnBack:
		// Проверяем режим: создание или редактирование
		if isEdit, ok := userState.Data["is_edit_mode"].(bool); ok && isEdit {
			// Возвращаемся к деталям вопроса при редактировании
			delete(userState.Data, "is_edit_mode")
			delete(userState.Data, "edit_question_position")
			s.stateMgr.SetState(userID, userState)
			s.stateMgr.NavigateTo(userID, "edit-question-detail")
		} else {
			// Возвращаемся в редактор при создании
			s.stateMgr.NavigateTo(userID, "simple-checklist-editor")
		}
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
		return
	default:
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
		return
	}

	// Сохраняем выбранный тип вопроса
	userState.Data["selected_question_type"] = string(category)
	s.stateMgr.SetState(userID, userState)

	// Переходим к вводу текста вопроса
	s.stateMgr.NavigateTo(userID, "enter-question-text")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[QuestionEditService] ✅ Выбран тип вопроса: %s", category)
}

// HandleConfirmDelete подтверждает удаление вопроса
func (s *QuestionEditService) HandleConfirmDelete(userID int64, update tgbotapi.Update, userState *state.UserState) {
	idx, ok := userState.Data["edit_question_index"].(int)
	if !ok {
		s.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка: не найден индекс вопроса")
		return
	}

	// Проверяем, удаляем ли вопрос из блока
	isBlockQuestion, _ := userState.Data["is_edit_block_questions"].(bool)

	if isBlockQuestion {
		// Удаление вопроса из блока
		checklistData, _ := s.stateMgr.GetCheckList(userID)
		checklist := checklistData.(*types.BlockedCheckList)
		blockIdx, _ := userState.Data["current_block_index"].(int)

		// Удаляем вопрос из блока
		block := &checklist.Blocks[blockIdx]
		block.Questions = append(block.Questions[:idx], block.Questions[idx+1:]...)

		// Обновляем количество
		total := len(block.Questions)
		userState.Data["total_questions"] = total

		// Если вопросов не осталось - возвращаемся в редактор блока
		if total == 0 {
			delete(userState.Data, "is_edit_block_questions")
			delete(userState.Data, "edit_question_index")
			s.stateMgr.SetState(userID, userState)
			s.stateMgr.NavigateTo(userID, "block-editor")
			s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
			return
		}

		// Корректируем индекс если нужно
		if idx >= total {
			idx = total - 1
		}
		userState.Data["edit_question_index"] = idx

		// Возвращаемся к списку вопросов блока
		s.stateMgr.NavigateTo(userID, "block-view-questions")
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

		log.Printf("[QuestionEditService] ✅ Вопрос %d удален из блока", idx+1)
	} else {
		// Удаление вопроса из простого чек-листа
		checklistData, _ := s.stateMgr.GetCheckList(userID)
		simpleChecklist := checklistData.(*types.SimpleCheckList)

		// Удаляем вопрос
		simpleChecklist.Questions = append(simpleChecklist.Questions[:idx], simpleChecklist.Questions[idx+1:]...)

		// Обновляем количество
		total := len(simpleChecklist.Questions)
		userState.Data["total_questions"] = total

		// Если вопросов не осталось - возвращаемся в редактор
		if total == 0 {
			delete(userState.Data, "edit_question_index")
			s.stateMgr.NavigateTo(userID, "simple-checklist-editor")
			s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
			return
		}

		// Корректируем индекс если нужно
		if idx >= total {
			idx = total - 1
		}
		userState.Data["edit_question_index"] = idx

		// Возвращаемся к списку вопросов
		s.stateMgr.NavigateTo(userID, "view-question")
		s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

		log.Printf("[QuestionEditService] ✅ Вопрос %d удален", idx+1)
	}
}

// HandleCancelDelete отменяет удаление вопроса
func (s *QuestionEditService) HandleCancelDelete(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Возвращаемся к деталям вопроса
	s.stateMgr.NavigateTo(userID, "edit-question-detail")
	s.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\question_edit\service.go ===
package question_edit

import (
	"telegram-bot/internal/services/answers"
	"telegram-bot/internal/services/question"
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/manager"
)

type QuestionEditService struct {
	stateMgr    manager.StateManager
	screenSvc   *screen.ScreenService
	questionSvc *question.QuestionService
	answersSvc  *answers.AnswersService
}

func NewQuestionEditService(stateMgr manager.StateManager, screenSvc *screen.ScreenService, questionSvc *question.QuestionService, answersSvc *answers.AnswersService) *QuestionEditService {
	return &QuestionEditService{
		stateMgr:    stateMgr,
		screenSvc:   screenSvc,
		questionSvc: questionSvc,
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\screen\service.go ===
package screen

import (
	"telegram-bot/internal/screens"
	"telegram-bot/internal/state_manager/state"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// ScreenService отвечает за отправку экранов пользователю
type ScreenService struct {
	bot *tgbotapi.BotAPI
}

// NewScreenService создает новый сервис экранов
func NewScreenService(bot *tgbotapi.BotAPI) *ScreenService {
	return &ScreenService{bot: bot}
}

// SendScreen отправляет конкретный экран
func (s *ScreenService) SendScreen(chatID int64, screen string, userState *state.UserState) error {
	// Получаем клавиатуру и сообщение для экрана
	keyboard := screens.GetKeyboardForState(userState)
	message := screens.GetMessageForScreen(screen, userState)

	// Создаем и отправляем сообщение
	msg := tgbotapi.NewMessage(chatID, message)
	msg.ReplyMarkup = keyboard

	_, err := s.bot.Send(msg)
	return err
}

// SendCurrentScreen отправляет текущий экран пользователя
func (s *ScreenService) SendCurrentScreen(chatID int64, userState *state.UserState) error {
	currentScreen := userState.GetCurrentScreen()
	if currentScreen == "" {
		currentScreen = "authorize-admin"
	}
	return s.SendScreen(chatID, currentScreen, userState)
}

// SendMessage отправляет простое сообщение
func (s *ScreenService) SendMessage(chatID int64, message string) error {
	msg := tgbotapi.NewMessage(chatID, message)
	_, err := s.bot.Send(msg)
	return err
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\simple_checklist\handlers.go ===
package simple_checklist

import (
	"fmt"
	"log"
	"strings"

	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"
	"telegram-bot/internal/storage/models"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// ========== Методы для ввода названия ==========

// HandleCancelCreateSimpleChecklistName - отмена создания названия
func (r *SimpleChecklistService) HandleCancelCreateSimpleChecklistName(userID int64, update tgbotapi.Update, userState *state.UserState) {
	r.stateMgr.NavigateTo(userID, "admin-menu")
	r.screenSvc.SendScreen(update.Message.Chat.ID, "admin-menu", userState)
}

// HandleCreateSimpleChecklistName - создание названия простого чек-листа
func (r *SimpleChecklistService) HandleCreateSimpleChecklistName(userID int64, update tgbotapi.Update, userState *state.UserState, text string) {
	checklist := types.NewDraftSimpleCheckList(text)
	userState.SetSimpleCheckList(checklist)
	r.stateMgr.SetState(userID, userState)
	r.stateMgr.NavigateTo(userID, "simple-checklist-editor")
	r.screenSvc.SendScreen(update.Message.Chat.ID, "simple-checklist-editor", userState)
}

// ========== Методы для редактора чек-листа ==========

// HandleBtnBackToMainMenu - возврат в главное меню
func (r *SimpleChecklistService) HandleBtnBackToMainMenu(userID int64, update tgbotapi.Update, userState *state.UserState) {
	r.stateMgr.NavigateTo(userID, "admin-menu")
	r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleBtnAddQuestion - добавление вопроса
func (r *SimpleChecklistService) HandleBtnAddQuestion(userID int64, update tgbotapi.Update, userState *state.UserState) {
	r.stateMgr.NavigateTo(userID, "select-question-type")
	r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleEditTitle - начало редактирования названия
func (r *SimpleChecklistService) HandleEditTitle(userID int64, update tgbotapi.Update, userState *state.UserState) {
	r.stateMgr.NavigateTo(userID, "edit-checklist-title")
	r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleNewTitleInput - обработка ввода нового названия
func (r *SimpleChecklistService) HandleNewTitleInput(userID int64, update tgbotapi.Update, userState *state.UserState, newTitle string) {
	// Проверяем, что название не пустое
	if len(strings.TrimSpace(newTitle)) == 0 {
		r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Название не может быть пустым")
		return
	}

	// Проверяем максимальную длину
	if len(newTitle) > 100 {
		r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Название слишком длинное (максимум 100 символов)")
		return
	}

	// Получаем текущий чек-лист
	checklistData, exists := r.stateMgr.GetCheckList(userID)
	if !exists {
		r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	// Меняем название в зависимости от типа чек-листа
	switch checklist := checklistData.(type) {
	case *types.SimpleCheckList:
		oldName := checklist.Name
		checklist.Name = newTitle
		log.Printf("[SimpleChecklistService] ✅ Название простого чек-листа изменено: '%s' → '%s'", oldName, newTitle)
	}

	// Возвращаемся в редактор
	r.stateMgr.NavigateTo(userID, "simple-checklist-editor")
	r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleEditQuestions - начало редактирования вопросов
func (r *SimpleChecklistService) HandleEditQuestions(userID int64, update tgbotapi.Update, userState *state.UserState) {
	r.questionEditSvc.HandleEditQuestions(userID, update, userState)
}

// HandlePreview - показ превью чек-листа
func (r *SimpleChecklistService) HandlePreview(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Проверяем, есть ли вопросы в чек-листе
	checklistData, exists := r.stateMgr.GetCheckList(userID)
	if !exists {
		r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	simpleChecklist, ok := checklistData.(*types.SimpleCheckList)
	if !ok {
		// Если это не SimpleCheckList - показываем сообщение
		r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Превью для этого типа чек-листа недоступно")
		return
	}

	hasQuestions := len(simpleChecklist.Questions) > 0

	if !hasQuestions {
		r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист пустой. Добавьте вопросы перед просмотром превью.")
		return
	}

	// Переходим к экрану превью
	r.stateMgr.NavigateTo(userID, "checklist-preview")
	r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleBack - обработка кнопки "Назад"
func (r *SimpleChecklistService) HandleBack(userID int64, update tgbotapi.Update, userState *state.UserState) {
	currentScreen := userState.GetCurrentScreen()

	switch currentScreen {
	case "edit-checklist-title":
		// Возвращаемся из редактирования названия в редактор
		r.stateMgr.NavigateTo(userID, "simple-checklist-editor")
	case "checklist-preview":
		// Возвращаемся из превью в редактор
		r.stateMgr.NavigateTo(userID, "simple-checklist-editor")
	case "confirm-exit-to-main-menu":
		// Возвращаемся из подтверждения выхода в редактор
		r.stateMgr.NavigateTo(userID, "simple-checklist-editor")
	default:
		r.stateMgr.NavigateTo(userID, "simple-checklist-editor")
	}

	r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleSaveDraft - сохранение черновика
func (r *SimpleChecklistService) HandleSaveDraft(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Получаем текущий чек-лист
	checklistData, exists := r.stateMgr.GetCheckList(userID)
	if !exists {
		r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	simpleChecklist, ok := checklistData.(*types.SimpleCheckList)
	if !ok {
		r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Неверный тип чек-листа для сохранения")
		return
	}

	// Проверяем, есть ли вопросы
	if len(simpleChecklist.Questions) == 0 {
		r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Нельзя сохранить пустой чек-лист. Добавьте хотя бы один вопрос.")
		return
	}

	var savedChecklist *models.Checklist
	var err error

	// Проверяем, редактируем ли существующий чек-лист (ID > 0)
	if simpleChecklist.ID > 0 {
		// РЕДАКТИРОВАНИЕ: удаляем старый и создаем новый
		log.Printf("[SimpleChecklistService] Редактирование чек-листа ID=%d", simpleChecklist.ID)
		savedChecklist, err = r.checklistSvc.UpdateChecklist(simpleChecklist.ID, simpleChecklist, userID)
		if err != nil {
			r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка обновления: "+err.Error())
			return
		}
		log.Printf("[SimpleChecklistService] Старый чек-лист %d удален, создан новый ID=%d",
			simpleChecklist.ID, savedChecklist.ID)
	} else {
		// СОЗДАНИЕ: просто создаем новый
		log.Printf("[SimpleChecklistService] Создание нового чек-листа")
		savedChecklist, err = r.checklistSvc.SaveSimpleChecklistDraft(simpleChecklist, userID)
		if err != nil {
			r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка сохранения: "+err.Error())
			return
		}
	}

	// Отправляем сообщение об успехе с указанием нового ID
	var message string
	if simpleChecklist.ID > 0 {
		message = fmt.Sprintf("✅ Чек-лист обновлен!\n\n📋 Название: %s\n🔄 Старый ID: %d → Новый ID: %d\n📊 Вопросов: %d\n\nЧек-лист доступен в разделе 'Мои чек-листы'",
			savedChecklist.Name, simpleChecklist.ID, savedChecklist.ID, len(simpleChecklist.Questions))
	} else {
		message = fmt.Sprintf("✅ Черновик сохранен!\n\n📋 Название: %s\n🏷️ ID: %d\n📊 Вопросов: %d\n\nЧек-лист доступен в разделе 'Мои чек-листы'",
			savedChecklist.Name, savedChecklist.ID, len(simpleChecklist.Questions))
	}

	r.screenSvc.SendMessage(update.Message.Chat.ID, message)

	// Очищаем состояние и возвращаемся в главное меню
	r.stateMgr.ClearCheckList(userID)
	r.stateMgr.NavigateTo(userID, "admin-menu")
	r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleSavePublish - сохранение и публикация
func (r *SimpleChecklistService) HandleSavePublish(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Получаем текущий чек-лист
	checklistData, exists := r.stateMgr.GetCheckList(userID)
	if !exists {
		r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Чек-лист не найден")
		return
	}

	simpleChecklist, ok := checklistData.(*types.SimpleCheckList)
	if !ok {
		r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Неверный тип чек-листа для публикации")
		return
	}

	// Проверяем, есть ли вопросы
	if len(simpleChecklist.Questions) == 0 {
		r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Нельзя опубликовать пустой чек-лист. Добавьте хотя бы один вопрос.")
		return
	}

	var savedChecklist *models.Checklist
	var err error

	// Проверяем, редактируем ли существующий чек-лист (ID > 0)
	if simpleChecklist.ID > 0 {
		// РЕДАКТИРОВАНИЕ: удаляем старый и создаем новый
		log.Printf("[SimpleChecklistService] Редактирование и публикация чек-листа ID=%d", simpleChecklist.ID)
		savedChecklist, err = r.checklistSvc.UpdateChecklist(simpleChecklist.ID, simpleChecklist, userID)
		if err != nil {
			r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка обновления: "+err.Error())
			return
		}
	} else {
		// СОЗДАНИЕ: просто создаем новый
		log.Printf("[SimpleChecklistService] Создание и публикация нового чек-листа")
		savedChecklist, err = r.checklistSvc.SaveSimpleChecklistDraft(simpleChecklist, userID)
		if err != nil {
			r.screenSvc.SendMessage(update.Message.Chat.ID, "❌ Ошибка сохранения: "+err.Error())
			return
		}
	}

	// Публикуем чек-лист
	err = r.checklistSvc.PublishChecklist(savedChecklist.ID)
	if err != nil {
		r.screenSvc.SendMessage(update.Message.Chat.ID, "⚠️ Чек-лист сохранен как черновик, но не опубликован: "+err.Error())

		// Показываем сообщение с новым ID
		var msg string
		if simpleChecklist.ID > 0 {
			msg = fmt.Sprintf("🔄 Чек-лист обновлен как черновик\n\n📋 Название: %s\n🔄 Старый ID: %d → Новый ID: %d\n📊 Вопросов: %d\n\nНо не опубликован из-за ошибки",
				savedChecklist.Name, simpleChecklist.ID, savedChecklist.ID, len(simpleChecklist.Questions))
		} else {
			msg = fmt.Sprintf("✅ Черновик сохранен!\n\n📋 Название: %s\n🏷️ ID: %d\n📊 Вопросов: %d\n\nНо не опубликован из-за ошибки",
				savedChecklist.Name, savedChecklist.ID, len(simpleChecklist.Questions))
		}
		r.screenSvc.SendMessage(update.Message.Chat.ID, msg)
	} else {
		// Успешная публикация
		var message string
		if simpleChecklist.ID > 0 {
			message = fmt.Sprintf("🚀 Чек-лист обновлен и опубликован!\n\n📋 Название: %s\n🔄 Старый ID: %d → Новый ID: %d\n📊 Вопросов: %d\n\nТеперь чек-лист доступен для прохождения",
				savedChecklist.Name, simpleChecklist.ID, savedChecklist.ID, len(simpleChecklist.Questions))
		} else {
			message = fmt.Sprintf("🚀 Чек-лист опубликован!\n\n📋 Название: %s\n🏷️ ID: %d\n📊 Вопросов: %d\n\nТеперь чек-лист доступен для прохождения",
				savedChecklist.Name, savedChecklist.ID, len(simpleChecklist.Questions))
		}
		r.screenSvc.SendMessage(update.Message.Chat.ID, message)
	}

	// Очищаем состояние и возвращаемся в главное меню
	r.stateMgr.ClearCheckList(userID)
	r.stateMgr.NavigateTo(userID, "admin-menu")
	r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleConfirmExit - начало процесса подтверждения выхода
func (r *SimpleChecklistService) HandleConfirmExit(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Переходим к экрану подтверждения выхода
	r.stateMgr.NavigateTo(userID, "confirm-exit-to-main-menu")
	r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)
}

// HandleConfirmExitYes - подтверждение выхода в главное меню
func (r *SimpleChecklistService) HandleConfirmExitYes(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Очищаем чек-лист
	r.stateMgr.ClearCheckList(userID)

	// Переходим в главное меню
	r.stateMgr.NavigateTo(userID, "admin-menu")
	r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[SimpleChecklistService] ✅ Пользователь %d вышел в главное меню", userID)
}

// HandleConfirmExitNo - отмена выхода в главное меню
func (r *SimpleChecklistService) HandleConfirmExitNo(userID int64, update tgbotapi.Update, userState *state.UserState) {
	// Возвращаемся в редактор чек-листа
	r.stateMgr.NavigateTo(userID, "simple-checklist-editor")
	r.screenSvc.SendCurrentScreen(update.Message.Chat.ID, userState)

	log.Printf("[SimpleChecklistService] ❌ Пользователь %d отменил выход", userID)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\services\simple_checklist\service.go ===
package simple_checklist

import (
	"telegram-bot/internal/services/question_edit"
	"telegram-bot/internal/services/screen"
	"telegram-bot/internal/state_manager/manager"
	"telegram-bot/internal/storage/service"
)

// SimpleChecklistService - объединенный сервис для работы с простыми чек-листами
type SimpleChecklistService struct {
	stateMgr        manager.StateManager
	screenSvc       *screen.ScreenService
	questionEditSvc *question_edit.QuestionEditService
	checklistSvc    *service.ChecklistService
}

func NewSimpleChecklistService(
	stateMgr manager.StateManager,
	screenSvc *screen.ScreenService,
	questionEditSvc *question_edit.QuestionEditService,
	checklistSvc *service.ChecklistService,
) *SimpleChecklistService {
	return &SimpleChecklistService{
		stateMgr:        stateMgr,
		screenSvc:       screenSvc,
		questionEditSvc: questionEditSvc,
		checklistSvc:    checklistSvc,
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\state_manager\debug\formatter.go ===
package debug

import (
	"fmt"
	"strings"
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"
)

// DebugState возвращает состояние в формате структуры (как в JS объекте)
func DebugState(state *state.UserState) string {
	if state == nil {
		return "Состояние: nil"
	}

	var sb strings.Builder

	// User
	sb.WriteString("{\n")
	sb.WriteString(" user: {\n")
	if state.User != nil {
		sb.WriteString(fmt.Sprintf("             id: %d,\n", state.User.ID))
		sb.WriteString(fmt.Sprintf("             telegram_id: %d,\n", state.User.TelegramID))
		sb.WriteString(fmt.Sprintf("             username: %s,\n", state.User.Username))
		sb.WriteString(fmt.Sprintf("             full_name: %s,\n", state.User.FullName))
		sb.WriteString(fmt.Sprintf("             role: %s\n", state.User.Role))
	} else {
		sb.WriteString("             id: null,\n")
		sb.WriteString("             telegram_id: null,\n")
		sb.WriteString("             username: null,\n")
		sb.WriteString("             full_name: null,\n")
		sb.WriteString("             role: null\n")
	}
	sb.WriteString("           },\n")

	// CurrentScreen (ЗАМЕНЯЕМ BreadCrumbs)
	sb.WriteString(fmt.Sprintf(" currentScreen: \"%s\",\n", state.CurrentScreen))

	// CurrentCheckList
	sb.WriteString(" currentCheckList: ")
	if state.CurrentCheckList == nil {
		sb.WriteString("null\n")
	} else {
		switch cl := state.CurrentCheckList.(type) {
		case *types.SimpleCheckList:
			debugSimpleCheckList(&sb, cl)
		case *types.BlockedCheckList:
			debugBlockedCheckList(&sb, cl)
		default:
			sb.WriteString("unknown type\n")
		}
	}

	sb.WriteString("}")
	return sb.String()
}

func debugSimpleCheckList(sb *strings.Builder, checkList *types.SimpleCheckList) {
	sb.WriteString("{\n")
	sb.WriteString(fmt.Sprintf("        id: %d,\n", checkList.ID))
	sb.WriteString(fmt.Sprintf("        name: \"%s\",\n", checkList.Name))
	sb.WriteString(fmt.Sprintf("        status: %s,\n", checkList.Status))

	// Questions
	sb.WriteString("        questions: [\n")
	for i, q := range checkList.Questions {
		if i > 0 {
			sb.WriteString(",\n")
		}
		sb.WriteString("          {\n")
		sb.WriteString(fmt.Sprintf("            text: \"%s\",\n", q.Text))
		sb.WriteString(fmt.Sprintf("            category: %s,\n", q.Category))

		// Answer options
		if len(q.AnswerOptions) > 0 {
			sb.WriteString("            answer_options: [\n")
			for j, opt := range q.AnswerOptions {
				if j > 0 {
					sb.WriteString(",\n")
				}
				sb.WriteString("              {\n")
				sb.WriteString(fmt.Sprintf("                text: \"%s\",\n", opt.Text))
				sb.WriteString(fmt.Sprintf("                is_correct: %v\n", opt.IsCorrect))
				sb.WriteString("              }")
			}
			sb.WriteString("\n            ]\n")
		} else {
			sb.WriteString("            answer_options: []\n")
		}
		sb.WriteString("          }")
	}
	if len(checkList.Questions) > 0 {
		sb.WriteString("\n")
	}
	sb.WriteString("        ]\n")
	sb.WriteString("    } \n")
}

func debugBlockedCheckList(sb *strings.Builder, checkList *types.BlockedCheckList) {
	sb.WriteString("{\n")
	sb.WriteString(fmt.Sprintf("        id: %d,\n", checkList.ID))
	sb.WriteString(fmt.Sprintf("        name: \"%s\",\n", checkList.Name))
	sb.WriteString(fmt.Sprintf("        status: %s,\n", checkList.Status))

	// Blocks
	sb.WriteString("        blocks: [\n")
	for i, block := range checkList.Blocks {
		if i > 0 {
			sb.WriteString(",\n")
		}
		sb.WriteString("          {\n")
		sb.WriteString(fmt.Sprintf("            name: \"%s\",\n", block.Name))

		// Questions in block
		sb.WriteString("            questions: [\n")
		for j, q := range block.Questions {
			if j > 0 {
				sb.WriteString(",\n")
			}
			sb.WriteString("              {\n")
			sb.WriteString(fmt.Sprintf("                text: \"%s\",\n", q.Text))
			sb.WriteString(fmt.Sprintf("                category: %s,\n", q.Category))

			// Answer options
			if len(q.AnswerOptions) > 0 {
				sb.WriteString("                answer_options: [\n")
				for k, opt := range q.AnswerOptions {
					if k > 0 {
						sb.WriteString(",\n")
					}
					sb.WriteString("                  {\n")
					sb.WriteString(fmt.Sprintf("                    text: \"%s\",\n", opt.Text))
					sb.WriteString(fmt.Sprintf("                    is_correct: %v\n", opt.IsCorrect))
					sb.WriteString("                  }")
				}
				sb.WriteString("\n                ]\n")
			} else {
				sb.WriteString("                answer_options: []\n")
			}
			sb.WriteString("              }")
		}
		if len(block.Questions) > 0 {
			sb.WriteString("\n")
		}
		sb.WriteString("            ]\n")
		sb.WriteString("          }")
	}
	if len(checkList.Blocks) > 0 {
		sb.WriteString("\n")
	}
	sb.WriteString("        ]\n")
	sb.WriteString("    }\n")
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\state_manager\debug\printer.go ===
package debug

import (
	"fmt"
	"telegram-bot/internal/state_manager/state"
)

// PrintState выводит состояние в консоль
func PrintState(state *state.UserState) {
	fmt.Println(DebugState(state))
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\state_manager\manager\checklist.go ===
package manager

import "telegram-bot/internal/state_manager/types"

// SetSimpleCheckList устанавливает простой чек-лист
func (m *MemoryStateManager) SetSimpleCheckList(userID int64, checkList *types.SimpleCheckList) bool {
	m.mu.Lock()
	defer m.mu.Unlock()

	state, exists := m.states[userID]
	if !exists {
		return false
	}

	state.SetSimpleCheckList(checkList)
	return true
}

// SetBlockedCheckList устанавливает чек-лист с блоками
func (m *MemoryStateManager) SetBlockedCheckList(userID int64, checkList *types.BlockedCheckList) bool {
	m.mu.Lock()
	defer m.mu.Unlock()

	state, exists := m.states[userID]
	if !exists {
		return false
	}

	state.SetBlockedCheckList(checkList)
	return true
}

// GetCheckList возвращает текущий чек-лист
func (m *MemoryStateManager) GetCheckList(userID int64) (types.CheckListData, bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	state, exists := m.states[userID]
	if !exists || state.CurrentCheckList == nil {
		return nil, false
	}

	return state.CurrentCheckList, true
}

// ClearCheckList очищает текущий чек-лист
func (m *MemoryStateManager) ClearCheckList(userID int64) bool {
	m.mu.Lock()
	defer m.mu.Unlock()

	state, exists := m.states[userID]
	if !exists {
		return false
	}

	state.ClearCheckList()
	return true
}

// HasCheckList проверяет наличие чек-листа
func (m *MemoryStateManager) HasCheckList(userID int64) bool {
	m.mu.RLock()
	defer m.mu.RUnlock()

	state, exists := m.states[userID]
	if !exists {
		return false
	}

	return state.HasCheckList()
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\state_manager\manager\crud.go ===
package manager

import "telegram-bot/internal/state_manager/state"

// GetState возвращает состояние пользователя
func (m *MemoryStateManager) GetState(userID int64) (*state.UserState, bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	state, exists := m.states[userID]
	if !exists {
		return nil, false
	}

	return state, true
}

// SetState устанавливает состояние пользователя
func (m *MemoryStateManager) SetState(userID int64, userState *state.UserState) {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.states[userID] = userState
}

// DeleteState удаляет состояние пользователя
func (m *MemoryStateManager) DeleteState(userID int64) {
	m.mu.Lock()
	defer m.mu.Unlock()
	delete(m.states, userID)
}

// NavigateTo переводит пользователя на новый экран (ПРОСТО УСТАНАВЛИВАЕМ ЭКРАН)
func (m *MemoryStateManager) NavigateTo(userID int64, screen string) bool {
	m.mu.Lock()
	defer m.mu.Unlock()

	state, exists := m.states[userID]
	if !exists {
		return false
	}

	state.SetCurrentScreen(screen)
	return true
}

// GetCurrentScreen возвращает текущий экран пользователя
func (m *MemoryStateManager) GetCurrentScreen(userID int64) (string, bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	state, exists := m.states[userID]
	if !exists {
		return "", false
	}

	return state.GetCurrentScreen(), true
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\state_manager\manager\interface.go ===
package manager

import (
	"telegram-bot/internal/state_manager/state"
	"telegram-bot/internal/state_manager/types"
	// "time"
)

// StateManager интерфейс менеджера состояний
type StateManager interface {
	// Основные операции
	GetState(userID int64) (*state.UserState, bool)
	SetState(userID int64, state *state.UserState)
	DeleteState(userID int64)

	// Работа с навигацией
	NavigateTo(userID int64, screen string) bool
	GetCurrentScreen(userID int64) (string, bool)

	// Работа с чек-листами
	SetSimpleCheckList(userID int64, checkList *types.SimpleCheckList) bool
	SetBlockedCheckList(userID int64, checkList *types.BlockedCheckList) bool
	GetCheckList(userID int64) (types.CheckListData, bool)
	ClearCheckList(userID int64) bool
	HasCheckList(userID int64) bool
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\state_manager\manager\memory_manager.go ===
package manager

import (
	"sync"
	"telegram-bot/internal/state_manager/state"
)

// MemoryStateManager - реализация StateManager
type MemoryStateManager struct {
	states    map[int64]*state.UserState
	mu        sync.RWMutex
	stopChan  chan struct{}
	isRunning bool
}

// NewMemoryStateManager создает новый менеджер состояний
func NewMemoryStateManager() *MemoryStateManager {
	return &MemoryStateManager{
		states:   make(map[int64]*state.UserState),
		stopChan: make(chan struct{}),
	}
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\state_manager\state\checklist_state.go ===
package state

import (
	"telegram-bot/internal/state_manager/types"
)

// SetSimpleCheckList устанавливает простой чек-лист
func (s *UserState) SetSimpleCheckList(checkList *types.SimpleCheckList) {
	s.CurrentCheckList = checkList
}

// SetBlockedCheckList устанавливает чек-лист с блоками
func (s *UserState) SetBlockedCheckList(checkList *types.BlockedCheckList) {
	s.CurrentCheckList = checkList
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\state_manager\state\user_state.go ===
package state

import (
	"telegram-bot/internal/state_manager/types"
)

// UserState - полное состояние пользователя
type UserState struct {
	User             *types.User            `json:"user"`
	CurrentScreen    string                 `json:"current_screen"`
	CurrentCheckList types.CheckListData    `json:"current_check_list,omitempty"`
	Data             map[string]interface{} `json:"data,omitempty"`
}

// NewUserState создает новое состояние пользователя
func NewUserState(user *types.User, initialScreen string) *UserState {
	if user == nil {
		user = &types.User{
			ID:         -1,
			TelegramID: -1,
			Username:   "",
			FullName:   "",
			Role:       types.RoleUser,
		}
	}

	state := &UserState{
		User:          user,
		CurrentScreen: initialScreen,
		Data:          make(map[string]interface{}),
	}

	return state
}

// SetUser обновляет пользователя
func (s *UserState) SetUser(user *types.User) {
	s.User = user
}

// SetCurrentScreen устанавливает текущий экран
func (s *UserState) SetCurrentScreen(screen string) {
	s.CurrentScreen = screen
}

// GetCurrentScreen возвращает текущий экран
func (s *UserState) GetCurrentScreen() string {
	return s.CurrentScreen
}

// ClearCheckList очищает текущий чек-лист
func (s *UserState) ClearCheckList() {
	s.CurrentCheckList = nil
}

// HasCheckList проверяет наличие чек-листа
func (s *UserState) HasCheckList() bool {
	return s.CurrentCheckList != nil
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\state_manager\types\checklist.go ===
package types

// CheckListData - интерфейс для данных чек-листа
type CheckListData interface {
	GetType() CheckListType
	GetID() int64
	GetName() string
	GetStatus() CheckListStatus
}

// SimpleCheckList - простой чек-лист
type SimpleCheckList struct {
	ID        int64           `json:"id"`
	Name      string          `json:"name"`
	Status    CheckListStatus `json:"status"`
	Questions []Question      `json:"questions"`
}

func (s *SimpleCheckList) GetType() CheckListType     { return TypeSimple }
func (s *SimpleCheckList) GetID() int64               { return s.ID }
func (s *SimpleCheckList) GetName() string            { return s.Name }
func (s *SimpleCheckList) GetStatus() CheckListStatus { return s.Status }

// NewDraftSimpleCheckList создает черновик простого чек-листа
func NewDraftSimpleCheckList(name string) *SimpleCheckList {
	return &SimpleCheckList{
		ID:        -1,
		Name:      name,
		Status:    StatusDraft,
		Questions: make([]Question, 0),
	}
}

// AddQuestion добавляет вопрос к простому чек-листу
func (c *SimpleCheckList) AddQuestion(question Question) {
	c.Questions = append(c.Questions, question)
}

// BlockedCheckList - чек-лист с блоками
type BlockedCheckList struct {
	ID     int64           `json:"id"`
	Name   string          `json:"name"`
	Status CheckListStatus `json:"status"`
	Blocks []Block         `json:"blocks"`
}

func (b *BlockedCheckList) GetType() CheckListType     { return TypeBlocked }
func (b *BlockedCheckList) GetID() int64               { return b.ID }
func (b *BlockedCheckList) GetName() string            { return b.Name }
func (b *BlockedCheckList) GetStatus() CheckListStatus { return b.Status }

// NewDraftBlockedCheckList создает черновик чек-листа с блоками
func NewDraftBlockedCheckList(name string) *BlockedCheckList {
	return &BlockedCheckList{
		ID:     -1,
		Name:   name,
		Status: StatusDraft,
		Blocks: make([]Block, 0),
	}
}

// AddBlock добавляет блок к чек-листу с блоками
func (c *BlockedCheckList) AddBlock(block Block) {
	c.Blocks = append(c.Blocks, block)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\state_manager\types\enums.go ===
package types

// UserRole - роли пользователя
type UserRole string

const (
	RoleUser  UserRole = "user"
	RoleAdmin UserRole = "admin"
)

// CheckListStatus - статусы чек-листа
type CheckListStatus string

const (
	StatusDraft       CheckListStatus = "draft"
	StatusPublished   CheckListStatus = "published"
	StatusUnpublished CheckListStatus = "unpublished"
)

// QuestionCategory - категории вопросов
type QuestionCategory string

const (
	CategoryCompliance     QuestionCategory = "compliance"
	CategorySingleChoice   QuestionCategory = "single_choice"
	CategoryMultipleChoice QuestionCategory = "multiple_choice"
	CategoryTextAnswer     QuestionCategory = "text_answer"
)

// CheckListType - тип чек-листа
type CheckListType string

const (
	TypeSimple  CheckListType = "simple"
	TypeBlocked CheckListType = "blocked"
)

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\state_manager\types\question.go ===
package types

// AnswerOption - вариант ответа
type AnswerOption struct {
	Text      string `json:"text"`
	IsCorrect bool   `json:"is_correct"`
}

// NewAnswerOption создает вариант ответа
func NewAnswerOption(text string, isCorrect bool) AnswerOption {
	return AnswerOption{
		Text:      text,
		IsCorrect: isCorrect,
	}
}

// Question - вопрос
type Question struct {
	Text          string           `json:"text"`
	Category      QuestionCategory `json:"category"`
	AnswerOptions []AnswerOption   `json:"answer_options,omitempty"`
}

// NewQuestion создает новый вопрос
func NewQuestion(text string, category QuestionCategory) Question {
	return Question{
		Text:          text,
		Category:      category,
		AnswerOptions: make([]AnswerOption, 0),
	}
}

// AddAnswerOption добавляет вариант ответа к вопросу
func (q *Question) AddAnswerOption(option AnswerOption) {
	q.AnswerOptions = append(q.AnswerOptions, option)
}

// Block - блок вопросов
type Block struct {
	Name      string     `json:"name"`
	Questions []Question `json:"questions"`
}

// NewBlock создает новый блок
func NewBlock(name string) Block {
	return Block{
		Name:      name,
		Questions: make([]Question, 0),
	}
}

// AddQuestion добавляет вопрос к блоку
func (b *Block) AddQuestion(question Question) {
	b.Questions = append(b.Questions, question)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\state_manager\types\user.go ===
package types

// User - структура пользователя
type User struct {
	ID         int64    `json:"id"`
	TelegramID int64    `json:"telegram_id"`
	Username   string   `json:"username"`
	FullName   string   `json:"full_name"`
	Role       UserRole `json:"role"`
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\infrastructure\database_client.go ===
package infrastructure

import (
	"context"
	"fmt"

	"github.com/nedpals/supabase-go"
)

type DatabaseClient struct {
	client *supabase.Client
}

func NewDatabaseClient(url, apiKey string) (*DatabaseClient, error) {
	if url == "" || apiKey == "" {
		return nil, fmt.Errorf("database URL and API key are required")
	}

	client := supabase.CreateClient(url, apiKey)
	return &DatabaseClient{client: client}, nil
}

func (d *DatabaseClient) HealthCheck(ctx context.Context) error {
	if d.client == nil {
		return fmt.Errorf("database client is not initialized")
	}
	return nil
}

func (d *DatabaseClient) Client() *supabase.Client {
	return d.client
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\models\answer_option.go ===
package models

import (
	"time"
)

// AnswerOption - вариант ответа
type AnswerOption struct {
	ID         int64     `json:"id,omitempty"` // omitempty
	QuestionID int64     `json:"question_id"`
	Text       string    `json:"text"`
	IsCorrect  bool      `json:"is_correct"`
	CreatedAt  time.Time `json:"created_at,omitempty"`
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\models\checklist.go ===
package models

import (
	"time"
)

// Типы статусов чек-листа
type ChecklistStatus string

const (
	StatusDraft       ChecklistStatus = "draft"
	StatusPublished   ChecklistStatus = "published"
	StatusUnpublished ChecklistStatus = "unpublished"
)

// Checklist - чек-лист
type Checklist struct {
	ID        int64           `json:"id,omitempty"` // omitempty чтобы не передавать при вставке
	Name      string          `json:"name"`
	UserID    int64           `json:"user_id"`
	Status    ChecklistStatus `json:"status"`
	CreatedAt time.Time       `json:"created_at,omitempty"`
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\models\checklist_template.go ===
package models

import (
	"time"
)

// ChecklistTemplate - шаблон связки чек-листа, вопроса и блока
type ChecklistTemplate struct {
	ID          int64     `json:"id,omitempty"` // omitempty
	ChecklistID int64     `json:"checklist_id"`
	QuestionID  int64     `json:"question_id"`
	BlockID     *int64    `json:"block_id,omitempty"`
	CreatedAt   time.Time `json:"created_at,omitempty"`
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\models\question.go ===
package models

import (
	"time"
)

// Типы вопросов
type QuestionCategory string

const (
	CategoryCompliance     QuestionCategory = "compliance"
	CategorySingleChoice   QuestionCategory = "single_choice"
	CategoryMultipleChoice QuestionCategory = "multiple_choice"
	CategoryTextAnswer     QuestionCategory = "text_answer"
)

// Question - вопрос
type Question struct {
	ID          int64            `json:"id,omitempty"` // omitempty
	Text        string           `json:"text"`
	Category    QuestionCategory `json:"category"`
	ChecklistID int64            `json:"checklist_id"`
	CreatedAt   time.Time        `json:"created_at,omitempty"`
	UpdatedAt   time.Time        `json:"updated_at,omitempty"`
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\models\question_block.go ===
package models

import (
	"time"
)

// QuestionBlock - блок вопросов
type QuestionBlock struct {
	ID          int64     `json:"id,omitempty"` // omitempty
	Name        string    `json:"name"`
	Description string    `json:"description,omitempty"`
	ChecklistID int64     `json:"checklist_id"`
	CreatedAt   time.Time `json:"created_at,omitempty"`
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\models\user.go ===
package models

import "time"

// Типизированные константы (enum-like)
type UserRole string

const (
	RoleUser  UserRole = "user"
	RoleAdmin UserRole = "admin"
)

// User - пользователь бота
type User struct {
	ID         int64     `json:"id"`
	TelegramID int64     `json:"telegram_id"`
	Username   string    `json:"username"`
	FullName   string    `json:"full_name"`
	Role       UserRole  `json:"role"`
	CreatedAt  time.Time `json:"created_at"`
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\repositories\answer_option.go ===
package repositories

import (
	"fmt"
	"strings"
	"telegram-bot/internal/storage/models"

	"github.com/nedpals/supabase-go"
)

// AnswerOptionRepository - репозиторий для работы с вариантами ответов
type AnswerOptionRepository struct {
	client *supabase.Client
}

// NewAnswerOptionRepository создает новый репозиторий для вариантов ответов
func NewAnswerOptionRepository(client *supabase.Client) *AnswerOptionRepository {
	return &AnswerOptionRepository{client: client}
}

// Create создает новый вариант ответа
func (r *AnswerOptionRepository) Create(option *models.AnswerOption) (*models.AnswerOption, error) {
	var result []models.AnswerOption

	err := r.client.DB.From("answer_options").
		Insert(option).
		Execute(&result)

	if err != nil {
		return nil, fmt.Errorf("failed to create answer option: %w", err)
	}

	if len(result) == 0 {
		return nil, fmt.Errorf("no answer option returned after creation")
	}

	return &result[0], nil
}

// CreateBatch создает несколько вариантов ответов
func (r *AnswerOptionRepository) CreateBatch(options []models.AnswerOption) ([]models.AnswerOption, error) {
	var result []models.AnswerOption

	if len(options) == 0 {
		return result, nil
	}

	err := r.client.DB.From("answer_options").
		Insert(options).
		Execute(&result)

	if err != nil {
		return nil, fmt.Errorf("failed to create answer options: %w", err)
	}

	return result, nil
}

// GetByQuestionID возвращает варианты ответов по ID вопроса
func (r *AnswerOptionRepository) GetByQuestionID(questionID int64) ([]models.AnswerOption, error) {
	var options []models.AnswerOption

	err := r.client.DB.From("answer_options").
		Select("*").
		Eq("question_id", fmt.Sprint(questionID)).
		Execute(&options)

	if err != nil {
		return nil, fmt.Errorf("failed to get answer options: %w", err)
	}

	return options, nil
}

// GetByQuestionIDs возвращает варианты ответов для нескольких вопросов
func (r *AnswerOptionRepository) GetByQuestionIDs(questionIDs []int64) ([]models.AnswerOption, error) {
	var options []models.AnswerOption

	if len(questionIDs) == 0 {
		return options, nil
	}

	// Создаем строку для фильтра IN
	var idStrings []string
	for _, id := range questionIDs {
		idStrings = append(idStrings, fmt.Sprint(id))
	}

	err := r.client.DB.From("answer_options").
		Select("*").
		Filter("question_id", "in", fmt.Sprintf("(%s)", strings.Join(idStrings, ","))).
		Execute(&options)

	if err != nil {
		return nil, fmt.Errorf("failed to get answer options: %w", err)
	}

	return options, nil
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\repositories\checklist.go ===
package repositories

import (
	"fmt"
	"log"
	"telegram-bot/internal/storage/models"

	"github.com/nedpals/supabase-go"
)

// ChecklistRepository - репозиторий для работы с чек-листами
type ChecklistRepository struct {
	client *supabase.Client
}

// NewChecklistRepository создает новый репозиторий для чек-листов
func NewChecklistRepository(client *supabase.Client) *ChecklistRepository {
	return &ChecklistRepository{client: client}
}

// Create создает новый чек-лист
func (r *ChecklistRepository) Create(checklist *models.Checklist) (*models.Checklist, error) {
	var result []models.Checklist

	err := r.client.DB.From("checklists").
		Insert(checklist).
		Execute(&result)

	if err != nil {
		return nil, fmt.Errorf("failed to create checklist: %w", err)
	}

	if len(result) == 0 {
		return nil, fmt.Errorf("no checklist returned after creation")
	}

	return &result[0], nil
}

// GetByID возвращает чек-лист по ID
func (r *ChecklistRepository) GetByID(id int64) (*models.Checklist, error) {
	var checklists []models.Checklist

	err := r.client.DB.From("checklists").
		Select("*").
		Eq("id", fmt.Sprint(id)).
		Execute(&checklists)

	if err != nil {
		return nil, fmt.Errorf("failed to get checklist: %w", err)
	}

	if len(checklists) == 0 {
		return nil, fmt.Errorf("checklist not found: %d", id)
	}

	return &checklists[0], nil
}

// GetByUserID возвращает чек-листы пользователя
func (r *ChecklistRepository) GetByUserID(userID int64, status *models.ChecklistStatus) ([]models.Checklist, error) {
	var checklists []models.Checklist

	query := r.client.DB.From("checklists").
		Select("*").
		Eq("user_id", fmt.Sprint(userID))

	if status != nil {
		query = query.Eq("status", string(*status))
	}

	err := query.Execute(&checklists)

	if err != nil {
		return nil, fmt.Errorf("failed to get user checklists: %w", err)
	}

	return checklists, nil
}

// UpdateStatus обновляет статус чек-листа
func (r *ChecklistRepository) UpdateStatus(id int64, status models.ChecklistStatus) error {
	data := map[string]interface{}{
		"status": status,
	}

	var result []models.Checklist
	err := r.client.DB.From("checklists").
		Update(data).
		Eq("id", fmt.Sprint(id)).
		Execute(&result)

	if err != nil {
		return fmt.Errorf("failed to update checklist status: %w", err)
	}

	return nil
}

// UpdateName обновляет название чек-листа
func (r *ChecklistRepository) UpdateName(id int64, name string) error {
	data := map[string]interface{}{
		"name": name,
	}

	var result []models.Checklist
	err := r.client.DB.From("checklists").
		Update(data).
		Eq("id", fmt.Sprint(id)).
		Execute(&result)

	if err != nil {
		return fmt.Errorf("failed to update checklist name: %w", err)
	}

	return nil
}

// Delete удаляет чек-лист по ID (с каскадным удалением)
func (r *ChecklistRepository) Delete(id int64) error {
	var result []models.Checklist

	err := r.client.DB.From("checklists").
		Delete().
		Eq("id", fmt.Sprint(id)).
		Execute(&result)

	if err != nil {
		return fmt.Errorf("failed to delete checklist: %w", err)
	}

	log.Printf("[ChecklistRepository] Чек-лист %d удален", id)
	return nil
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\repositories\checklist_template.go ===
package repositories

import (
	"fmt"
	"telegram-bot/internal/storage/models"

	"github.com/nedpals/supabase-go"
)

// ChecklistTemplateRepository - репозиторий для работы с шаблонами чек-листов
type ChecklistTemplateRepository struct {
	client *supabase.Client
}

// NewChecklistTemplateRepository создает новый репозиторий для шаблонов
func NewChecklistTemplateRepository(client *supabase.Client) *ChecklistTemplateRepository {
	return &ChecklistTemplateRepository{client: client}
}

// Create создает новую связку шаблона
func (r *ChecklistTemplateRepository) Create(template *models.ChecklistTemplate) (*models.ChecklistTemplate, error) {
	var result []models.ChecklistTemplate

	err := r.client.DB.From("checklist_templates").
		Insert(template).
		Execute(&result)

	if err != nil {
		return nil, fmt.Errorf("failed to create checklist template: %w", err)
	}

	if len(result) == 0 {
		return nil, fmt.Errorf("no checklist template returned after creation")
	}

	return &result[0], nil
}

// CreateBatch создает несколько связок шаблонов
func (r *ChecklistTemplateRepository) CreateBatch(templates []models.ChecklistTemplate) ([]models.ChecklistTemplate, error) {
	var result []models.ChecklistTemplate

	if len(templates) == 0 {
		return result, nil
	}

	err := r.client.DB.From("checklist_templates").
		Insert(templates).
		Execute(&result)

	if err != nil {
		return nil, fmt.Errorf("failed to create checklist templates: %w", err)
	}

	return result, nil
}

// GetByChecklistID возвращает шаблоны по ID чек-листа
func (r *ChecklistTemplateRepository) GetByChecklistID(checklistID int64) ([]models.ChecklistTemplate, error) {
	var templates []models.ChecklistTemplate

	err := r.client.DB.From("checklist_templates").
		Select("*").
		Eq("checklist_id", fmt.Sprint(checklistID)).
		Execute(&templates)

	if err != nil {
		return nil, fmt.Errorf("failed to get checklist templates: %w", err)
	}

	return templates, nil
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\repositories\interfaces.go ===
package repositories

import (
	"telegram-bot/internal/storage/models"
)

// интерфейс для работы с репозиториями
type Repositories interface {
	// User методы
	GetUserByTelegramID(telegramID int64) (*models.User, error)
}

// ChecklistRepositoryInterface - интерфейс для работы с чек-листами
type ChecklistRepositoryInterface interface {
	Create(checklist *models.Checklist) (*models.Checklist, error)
	GetByID(id int64) (*models.Checklist, error)
	GetByUserID(userID int64, status *models.ChecklistStatus) ([]models.Checklist, error)
	UpdateStatus(id int64, status models.ChecklistStatus) error
	UpdateName(id int64, name string) error
	Delete(id int64) error
}

// QuestionBlockRepositoryInterface - интерфейс для работы с блоками вопросов
type QuestionBlockRepositoryInterface interface {
	Create(block *models.QuestionBlock) (*models.QuestionBlock, error)
	CreateBatch(blocks []models.QuestionBlock) ([]models.QuestionBlock, error)
	GetByChecklistID(checklistID int64) ([]models.QuestionBlock, error)
	UpdateName(id int64, name string) error
}

// QuestionRepositoryInterface - интерфейс для работы с вопросами
type QuestionRepositoryInterface interface {
	Create(question *models.Question) (*models.Question, error)
	CreateBatch(questions []models.Question) ([]models.Question, error)
	GetByChecklistID(checklistID int64) ([]models.Question, error)
	UpdateText(id int64, text string) error
	UpdateCategory(id int64, category models.QuestionCategory) error
}

// AnswerOptionRepositoryInterface - интерфейс для работы с вариантами ответов
type AnswerOptionRepositoryInterface interface {
	Create(option *models.AnswerOption) (*models.AnswerOption, error)
	CreateBatch(options []models.AnswerOption) ([]models.AnswerOption, error)
	GetByQuestionID(questionID int64) ([]models.AnswerOption, error)
	GetByQuestionIDs(questionIDs []int64) ([]models.AnswerOption, error)
}

// ChecklistTemplateRepositoryInterface - интерфейс для работы с шаблонами
type ChecklistTemplateRepositoryInterface interface {
	Create(template *models.ChecklistTemplate) (*models.ChecklistTemplate, error)
	CreateBatch(templates []models.ChecklistTemplate) ([]models.ChecklistTemplate, error)
	GetByChecklistID(checklistID int64) ([]models.ChecklistTemplate, error)
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\repositories\question.go ===
package repositories

import (
	"fmt"
	"telegram-bot/internal/storage/models"

	"github.com/nedpals/supabase-go"
)

// QuestionRepository - репозиторий для работы с вопросами
type QuestionRepository struct {
	client *supabase.Client
}

// NewQuestionRepository создает новый репозиторий для вопросов
func NewQuestionRepository(client *supabase.Client) *QuestionRepository {
	return &QuestionRepository{client: client}
}

// Create создает новый вопрос
func (r *QuestionRepository) Create(question *models.Question) (*models.Question, error) {
	var result []models.Question

	err := r.client.DB.From("questions").
		Insert(question).
		Execute(&result)

	if err != nil {
		return nil, fmt.Errorf("failed to create question: %w", err)
	}

	if len(result) == 0 {
		return nil, fmt.Errorf("no question returned after creation")
	}

	return &result[0], nil
}

// CreateBatch создает несколько вопросов
func (r *QuestionRepository) CreateBatch(questions []models.Question) ([]models.Question, error) {
	var result []models.Question

	if len(questions) == 0 {
		return result, nil
	}

	err := r.client.DB.From("questions").
		Insert(questions).
		Execute(&result)

	if err != nil {
		return nil, fmt.Errorf("failed to create questions: %w", err)
	}

	return result, nil
}

// GetByChecklistID возвращает вопросы по ID чек-листа
func (r *QuestionRepository) GetByChecklistID(checklistID int64) ([]models.Question, error) {
	var questions []models.Question

	err := r.client.DB.From("questions").
		Select("*").
		Eq("checklist_id", fmt.Sprint(checklistID)).
		Execute(&questions)

	if err != nil {
		return nil, fmt.Errorf("failed to get questions: %w", err)
	}

	return questions, nil
}

// UpdateText обновляет текст вопроса
func (r *QuestionRepository) UpdateText(id int64, text string) error {
	data := map[string]interface{}{
		"text": text,
	}

	var result []models.Question
	err := r.client.DB.From("questions").
		Update(data).
		Eq("id", fmt.Sprint(id)).
		Execute(&result)

	if err != nil {
		return fmt.Errorf("failed to update question text: %w", err)
	}

	return nil
}

// UpdateCategory обновляет тип вопроса
func (r *QuestionRepository) UpdateCategory(id int64, category models.QuestionCategory) error {
	data := map[string]interface{}{
		"category": category,
	}

	var result []models.Question
	err := r.client.DB.From("questions").
		Update(data).
		Eq("id", fmt.Sprint(id)).
		Execute(&result)

	if err != nil {
		return fmt.Errorf("failed to update question category: %w", err)
	}

	return nil
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\repositories\question_block.go ===
package repositories

import (
	"fmt"
	"telegram-bot/internal/storage/models"

	"github.com/nedpals/supabase-go"
)

// QuestionBlockRepository - репозиторий для работы с блоками вопросов
type QuestionBlockRepository struct {
	client *supabase.Client
}

// NewQuestionBlockRepository создает новый репозиторий для блоков вопросов
func NewQuestionBlockRepository(client *supabase.Client) *QuestionBlockRepository {
	return &QuestionBlockRepository{client: client}
}

// Create создает новый блок вопросов
func (r *QuestionBlockRepository) Create(block *models.QuestionBlock) (*models.QuestionBlock, error) {
	var result []models.QuestionBlock

	err := r.client.DB.From("question_blocks").
		Insert(block).
		Execute(&result)

	if err != nil {
		return nil, fmt.Errorf("failed to create question block: %w", err)
	}

	if len(result) == 0 {
		return nil, fmt.Errorf("no question block returned after creation")
	}

	return &result[0], nil
}

// CreateBatch создает несколько блоков вопросов
func (r *QuestionBlockRepository) CreateBatch(blocks []models.QuestionBlock) ([]models.QuestionBlock, error) {
	var result []models.QuestionBlock

	if len(blocks) == 0 {
		return result, nil
	}

	err := r.client.DB.From("question_blocks").
		Insert(blocks).
		Execute(&result)

	if err != nil {
		return nil, fmt.Errorf("failed to create question blocks: %w", err)
	}

	return result, nil
}

// GetByChecklistID возвращает блоки вопросов по ID чек-листа
func (r *QuestionBlockRepository) GetByChecklistID(checklistID int64) ([]models.QuestionBlock, error) {
	var blocks []models.QuestionBlock

	err := r.client.DB.From("question_blocks").
		Select("*").
		Eq("checklist_id", fmt.Sprint(checklistID)).
		Execute(&blocks)

	if err != nil {
		return nil, fmt.Errorf("failed to get question blocks: %w", err)
	}

	return blocks, nil
}

// UpdateName обновляет название блока
func (r *QuestionBlockRepository) UpdateName(id int64, name string) error {
	data := map[string]interface{}{
		"name": name,
	}

	var result []models.QuestionBlock
	err := r.client.DB.From("question_blocks").
		Update(data).
		Eq("id", fmt.Sprint(id)).
		Execute(&result)

	if err != nil {
		return fmt.Errorf("failed to update question block name: %w", err)
	}

	return nil
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\repositories\user.go ===
package repositories

import (
	"fmt"
	"telegram-bot/internal/storage/models"

	"github.com/nedpals/supabase-go"
)

type SupabaseAdapter struct {
	client *supabase.Client
}

func NewSupabaseAdapter(client *supabase.Client) *SupabaseAdapter {
	return &SupabaseAdapter{client: client}
}

func (a *SupabaseAdapter) GetUserByTelegramID(telegramID int64) (*models.User, error) {
	var users []models.User

	err := a.client.DB.From("users").
		Select("*").
		Eq("telegram_id", fmt.Sprint(telegramID)).
		Execute(&users)

	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}
	if len(users) == 0 {
		return nil, fmt.Errorf("user not found: %d", telegramID)
	}
	return &users[0], nil
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\service\checklist.go ===
package service

import (
	"fmt"
	"log"
	"telegram-bot/internal/state_manager/types"
	"telegram-bot/internal/storage/models"
	"telegram-bot/internal/storage/repositories"
	"time"
)

// ChecklistService - сервис для работы с чек-листами
type ChecklistService struct {
	checklistRepo     repositories.ChecklistRepositoryInterface
	questionBlockRepo repositories.QuestionBlockRepositoryInterface
	questionRepo      repositories.QuestionRepositoryInterface
	answerOptionRepo  repositories.AnswerOptionRepositoryInterface
	templateRepo      repositories.ChecklistTemplateRepositoryInterface
	userRepo          repositories.Repositories // Добавляем репозиторий пользователей
}

// NewChecklistService создает новый сервис для чек-листов
func NewChecklistService(
	checklistRepo repositories.ChecklistRepositoryInterface,
	questionBlockRepo repositories.QuestionBlockRepositoryInterface,
	questionRepo repositories.QuestionRepositoryInterface,
	answerOptionRepo repositories.AnswerOptionRepositoryInterface,
	templateRepo repositories.ChecklistTemplateRepositoryInterface,
	userRepo repositories.Repositories, // Добавляем параметр
) *ChecklistService {
	return &ChecklistService{
		checklistRepo:     checklistRepo,
		questionBlockRepo: questionBlockRepo,
		questionRepo:      questionRepo,
		answerOptionRepo:  answerOptionRepo,
		templateRepo:      templateRepo,
		userRepo:          userRepo,
	}
}

// SaveSimpleChecklistDraft сохраняет простой чек-лист в базу данных
func (s *ChecklistService) SaveSimpleChecklistDraft(checklist *types.SimpleCheckList, telegramUserID int64) (*models.Checklist, error) {
	log.Printf("[ChecklistService] Сохранение простого чек-листа '%s' для пользователя %d", checklist.Name, telegramUserID)

	// 1. Получаем ID пользователя из базы по telegram_id
	user, err := s.userRepo.GetUserByTelegramID(telegramUserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	// 2. Создаем чек-лист в базе
	dbChecklist := &models.Checklist{
		Name:      checklist.Name,
		UserID:    user.ID, // Используем ID из таблицы users
		Status:    models.StatusDraft,
		CreatedAt: time.Now(),
	}

	createdChecklist, err := s.checklistRepo.Create(dbChecklist)
	if err != nil {
		return nil, fmt.Errorf("failed to create checklist: %w", err)
	}
	log.Printf("[ChecklistService] Чек-лист создан с ID: %d", createdChecklist.ID)

	// 3. Сохраняем вопросы и варианты ответов
	for i, question := range checklist.Questions {
		// Создаем вопрос в базе (без block_id для простых чек-листов)
		dbQuestion := &models.Question{
			Text:        question.Text,
			Category:    models.QuestionCategory(question.Category),
			ChecklistID: createdChecklist.ID,
			CreatedAt:   time.Now(),
			UpdatedAt:   time.Now(),
		}

		createdQuestion, err := s.questionRepo.Create(dbQuestion)
		if err != nil {
			return nil, fmt.Errorf("failed to create question %d: %w", i+1, err)
		}

		// 4. Сохраняем варианты ответов (если есть)
		if len(question.AnswerOptions) > 0 {
			var answerOptions []models.AnswerOption
			for _, option := range question.AnswerOptions {
				answerOptions = append(answerOptions, models.AnswerOption{
					QuestionID: createdQuestion.ID,
					Text:       option.Text,
					IsCorrect:  option.IsCorrect,
					CreatedAt:  time.Now(),
				})
			}

			if len(answerOptions) > 0 {
				_, err := s.answerOptionRepo.CreateBatch(answerOptions)
				if err != nil {
					return nil, fmt.Errorf("failed to create answer options for question %d: %w", i+1, err)
				}
			}
		}

		// 5. Создаем связку в checklist_templates (без block_id)
		template := &models.ChecklistTemplate{
			ChecklistID: createdChecklist.ID,
			QuestionID:  createdQuestion.ID,
			CreatedAt:   time.Now(),
		}

		_, err = s.templateRepo.Create(template)
		if err != nil {
			return nil, fmt.Errorf("failed to create checklist template for question %d: %w", i+1, err)
		}

		log.Printf("[ChecklistService] Вопрос %d сохранен с ID: %d", i+1, createdQuestion.ID)
	}

	log.Printf("[ChecklistService] Простой чек-лист успешно сохранен. ID: %d, вопросов: %d",
		createdChecklist.ID, len(checklist.Questions))

	return createdChecklist, nil
}

// SaveBlockedChecklistDraft сохраняет чек-лист с блоками в базу данных
func (s *ChecklistService) SaveBlockedChecklistDraft(checklist *types.BlockedCheckList, telegramUserID int64) (*models.Checklist, error) {
	log.Printf("[ChecklistService] Сохранение чек-листа с блоками '%s' для пользователя %d", checklist.Name, telegramUserID)

	// 1. Получаем ID пользователя из базы по telegram_id
	user, err := s.userRepo.GetUserByTelegramID(telegramUserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	// 2. Создаем чек-лист в базе
	dbChecklist := &models.Checklist{
		Name:      checklist.Name,
		UserID:    user.ID,
		Status:    models.StatusDraft,
		CreatedAt: time.Now(),
	}

	createdChecklist, err := s.checklistRepo.Create(dbChecklist)
	if err != nil {
		return nil, fmt.Errorf("failed to create checklist: %w", err)
	}
	log.Printf("[ChecklistService] Чек-лист создан с ID: %d", createdChecklist.ID)

	// 3. Сохраняем блоки
	for blockIndex, block := range checklist.Blocks {
		// Создаем блок в базе
		dbBlock := &models.QuestionBlock{
			Name:        block.Name,
			ChecklistID: createdChecklist.ID,
			CreatedAt:   time.Now(),
		}

		createdBlock, err := s.questionBlockRepo.Create(dbBlock)
		if err != nil {
			return nil, fmt.Errorf("failed to create block %d: %w", blockIndex+1, err)
		}
		log.Printf("[ChecklistService] Блок %d создан с ID: %d", blockIndex+1, createdBlock.ID)

		// 4. Сохраняем вопросы в блоке
		for questionIndex, question := range block.Questions {
			// Создаем вопрос в базе (БЕЗ block_id - его нет в таблице)
			dbQuestion := &models.Question{
				Text:        question.Text,
				Category:    models.QuestionCategory(question.Category),
				ChecklistID: createdChecklist.ID,
				CreatedAt:   time.Now(),
				UpdatedAt:   time.Now(),
			}

			createdQuestion, err := s.questionRepo.Create(dbQuestion)
			if err != nil {
				return nil, fmt.Errorf("failed to create question %d in block %d: %w",
					questionIndex+1, blockIndex+1, err)
			}

			// 5. Сохраняем варианты ответов (если есть)
			if len(question.AnswerOptions) > 0 {
				var answerOptions []models.AnswerOption
				for _, option := range question.AnswerOptions {
					answerOptions = append(answerOptions, models.AnswerOption{
						QuestionID: createdQuestion.ID,
						Text:       option.Text,
						IsCorrect:  option.IsCorrect,
						CreatedAt:  time.Now(),
					})
				}

				if len(answerOptions) > 0 {
					_, err := s.answerOptionRepo.CreateBatch(answerOptions)
					if err != nil {
						return nil, fmt.Errorf("failed to create answer options for question %d in block %d: %w",
							questionIndex+1, blockIndex+1, err)
					}
				}
			}

			// 6. Создаем связку в checklist_templates (с указанием block_id)
			template := &models.ChecklistTemplate{
				ChecklistID: createdChecklist.ID,
				QuestionID:  createdQuestion.ID,
				BlockID:     &createdBlock.ID, // Указываем ID блока в шаблоне
				CreatedAt:   time.Now(),
			}

			_, err = s.templateRepo.Create(template)
			if err != nil {
				return nil, fmt.Errorf("failed to create checklist template for question %d in block %d: %w",
					questionIndex+1, blockIndex+1, err)
			}

			log.Printf("[ChecklistService] Вопрос %d в блоке %d сохранен с ID: %d",
				questionIndex+1, blockIndex+1, createdQuestion.ID)
		}
	}

	// Подсчитываем общее количество вопросов
	totalQuestions := 0
	for _, block := range checklist.Blocks {
		totalQuestions += len(block.Questions)
	}

	log.Printf("[ChecklistService] Чек-лист с блоками успешно сохранен. ID: %d, блоков: %d, вопросов: %d",
		createdChecklist.ID, len(checklist.Blocks), totalQuestions)

	return createdChecklist, nil
}

// PublishChecklist публикует чек-лист
func (s *ChecklistService) PublishChecklist(checklistID int64) error {
	err := s.checklistRepo.UpdateStatus(checklistID, models.StatusPublished)
	if err != nil {
		return fmt.Errorf("failed to publish checklist: %w", err)
	}

	log.Printf("[ChecklistService] Чек-лист %d опубликован", checklistID)
	return nil
}

// GetUserDrafts возвращает черновики пользователя
func (s *ChecklistService) GetUserDrafts(telegramUserID int64) ([]models.Checklist, error) {
	// Получаем ID пользователя
	user, err := s.userRepo.GetUserByTelegramID(telegramUserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	status := models.StatusDraft
	return s.checklistRepo.GetByUserID(user.ID, &status)
}

// GetUserPublished возвращает опубликованные чек-листы пользователя
func (s *ChecklistService) GetUserPublished(telegramUserID int64) ([]models.Checklist, error) {
	// Получаем ID пользователя
	user, err := s.userRepo.GetUserByTelegramID(telegramUserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	status := models.StatusPublished
	return s.checklistRepo.GetByUserID(user.ID, &status)
}

// GetChecklistByID загружает чек-лист по ID со всеми данными
func (s *ChecklistService) GetChecklistByID(checklistID int64) (*models.Checklist, []models.QuestionBlock, []models.Question, []models.AnswerOption, error) {
	// 1. Получаем чек-лист
	checklist, err := s.checklistRepo.GetByID(checklistID)
	if err != nil {
		return nil, nil, nil, nil, fmt.Errorf("failed to get checklist: %w", err)
	}

	// 2. Получаем блоки вопросов
	blocks, err := s.questionBlockRepo.GetByChecklistID(checklistID)
	if err != nil {
		return nil, nil, nil, nil, fmt.Errorf("failed to get question blocks: %w", err)
	}

	// 3. Получаем вопросы
	questions, err := s.questionRepo.GetByChecklistID(checklistID)
	if err != nil {
		return nil, nil, nil, nil, fmt.Errorf("failed to get questions: %w", err)
	}

	// 4. Получаем варианты ответов
	var questionIDs []int64
	for _, q := range questions {
		questionIDs = append(questionIDs, q.ID)
	}

	var answerOptions []models.AnswerOption
	if len(questionIDs) > 0 {
		answerOptions, err = s.answerOptionRepo.GetByQuestionIDs(questionIDs)
		if err != nil {
			return nil, nil, nil, nil, fmt.Errorf("failed to get answer options: %w", err)
		}
	}

	return checklist, blocks, questions, answerOptions, nil
}

// DeleteChecklist удаляет чек-лист
func (s *ChecklistService) DeleteChecklist(checklistID int64) error {
	err := s.checklistRepo.Delete(checklistID)
	if err != nil {
		return fmt.Errorf("failed to delete checklist: %w", err)
	}

	log.Printf("[ChecklistService] Чек-лист %d удален", checklistID)
	return nil
}

// GetTemplatesByChecklistID возвращает шаблоны для чек-листа
func (s *ChecklistService) GetTemplatesByChecklistID(checklistID int64) ([]models.ChecklistTemplate, error) {
	return s.templateRepo.GetByChecklistID(checklistID)
}

// UpdateChecklist обновляет чек-лист (удаляет старый и создает новый)
func (s *ChecklistService) UpdateChecklist(oldChecklistID int64, checklistData types.CheckListData, telegramUserID int64) (*models.Checklist, error) {
	log.Printf("[ChecklistService] Обновление чек-листа ID=%d", oldChecklistID)

	// 1. Удаляем старый чек-лист (каскадно удалятся все дочерние записи)
	err := s.checklistRepo.Delete(oldChecklistID)
	if err != nil {
		return nil, fmt.Errorf("failed to delete old checklist: %w", err)
	}
	log.Printf("[ChecklistService] Старый чек-лист %d удален", oldChecklistID)

	// 2. Создаем новый чек-лист
	switch checklist := checklistData.(type) {
	case *types.SimpleCheckList:
		return s.SaveSimpleChecklistDraft(checklist, telegramUserID)
	case *types.BlockedCheckList:
		return s.SaveBlockedChecklistDraft(checklist, telegramUserID)
	default:
		return nil, fmt.Errorf("unknown checklist type")
	}
}

// GetUserUnpublished возвращает отмененные чек-листы пользователя
func (s *ChecklistService) GetUserUnpublished(telegramUserID int64) ([]models.Checklist, error) {
	// Получаем ID пользователя
	user, err := s.userRepo.GetUserByTelegramID(telegramUserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	status := models.StatusUnpublished
	return s.checklistRepo.GetByUserID(user.ID, &status)
}

// UnpublishChecklist снимает чек-лист с публикации
func (s *ChecklistService) UnpublishChecklist(checklistID int64) error {
	err := s.checklistRepo.UpdateStatus(checklistID, models.StatusUnpublished)
	if err != nil {
		return fmt.Errorf("failed to unpublish checklist: %w", err)
	}

	log.Printf("[ChecklistService] Чек-лист %d снят с публикации", checklistID)
	return nil
}

// RepublishChecklist возвращает чек-лист в публикацию
func (s *ChecklistService) RepublishChecklist(checklistID int64) error {
	err := s.checklistRepo.UpdateStatus(checklistID, models.StatusPublished)
	if err != nil {
		return fmt.Errorf("failed to republish checklist: %w", err)
	}

	log.Printf("[ChecklistService] Чек-лист %d возвращен в публикацию", checklistID)
	return nil
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\storage\service\user.go ===
package service

import (
	"fmt"
	"telegram-bot/internal/storage/models"
	"telegram-bot/internal/storage/repositories"
)

type UserService struct {
	user repositories.Repositories
}

func NewUserService(user repositories.Repositories) *UserService {
	return &UserService{user: user}
}

func (s *UserService) AuthorizeAdmin(telegramID int64) (*models.User, error) {
	user, err := s.user.GetUserByTelegramID(telegramID)
	if err != nil {
		return nil, fmt.Errorf("у вас нет доступа к боту")
	}

	if user.Role != models.RoleAdmin {
		return nil, fmt.Errorf("доступ запрещен: требуется роль администратора")
	}

	return user, nil
}

=== C:\telegramm_bots_new\check-list-admin-bot-new\internal\utils\button_utils.go ===
package utils

import (
	"strconv"
	"strings"
)

// IsPencilNumberButton проверяет, является ли текст кнопкой с карандашом и номером
func IsPencilNumberButton(text string) bool {
	text = strings.TrimSpace(text)
	if text == "" {
		return false
	}

	// Проверяем, начинается ли с карандаша
	if !strings.HasPrefix(text, "✏️") {
		return false
	}

	// Убираем карандаш и пробелы
	cleanText := strings.TrimPrefix(text, "✏️")
	cleanText = strings.TrimSpace(cleanText)

	if cleanText == "" {
		return false
	}

	// Используем strconv.Atoi для проверки (более надежно)
	_, err := strconv.Atoi(cleanText)
	return err == nil
}

// ExtractNumberFromPencilButton извлекает номер из кнопки с карандашом
func ExtractNumberFromPencilButton(text string) (int, error) {
	text = strings.TrimSpace(text)
	if text == "" {
		return 0, strconv.ErrSyntax
	}

	// Убираем карандаш и пробелы
	cleanText := strings.TrimPrefix(text, "✏️")
	cleanText = strings.TrimSpace(cleanText)

	if cleanText == "" {
		return 0, strconv.ErrSyntax
	}

	return strconv.Atoi(cleanText)
}

// ExtractBlockIndexFromButton - извлекает индекс блока из текста кнопки
func ExtractBlockIndexFromButton(buttonText string) (int, bool) {
	// Формат: "🧱 1. Название (3)" или "📭 1. Название (0)"
	parts := strings.SplitN(buttonText, ".", 2)
	if len(parts) < 2 {
		return -1, false
	}

	// Извлекаем номер из первой части (убираем эмодзи и пробелы)
	numPart := strings.TrimSpace(parts[0])
	// Убираем эмодзи
	for i, r := range numPart {
		if r >= '0' && r <= '9' {
			numPart = numPart[i:]
			break
		}
	}

	index, err := strconv.Atoi(numPart)
	if err != nil {
		return -1, false
	}

	return index - 1, true // Конвертируем в 0-based индекс
}

